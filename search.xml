<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Set、Map、WeakSet、WeakMap的区别]]></title>
    <url>%2Fweb%2FLP20190710A%2F</url>
    <content type="text"><![CDATA[“Good programmers use their brains, but good guidelines save us having to think out every case.”—Francis Glassborow 前言 大多数主流编程语言都有多种内置的数据集合。例如Python拥有列表（list）、元组（tuple）和字典（dictionary）,Java有列表（list）、集合（set)、队列（queue）。然而JavaScript直到ES6的发布之前，只拥有数组（array）和对象（object）这两个内建的数据集合。ES6的出现，引入了诸如Map、Set、WeakeMap、WeakMap等新的数据结构为这门语言注入了新的能量和活力。 HashMap，Dictionary等数据结构是各种编程语言存储键/值对的几种方式，这些数据结构针对快速检索进行了优化。当然ES6中的Map、Set、WeakeMap、WeakMap这些数据结构底层都是通过（hash tables）散列表实现的。 Map在ES5中,我们通常使用内置的Object（它们只是具有键和值的属性的任意集合）模拟Map。但是这样做会有三个缺陷。 JavaScript中Object的属性键是String或Symbol，这限制了它们作为不同数据类型的键/值对集合的能力。当然，您可以将其他数据类型强制/字符串化为字符串，但这会增加额外的工作量。 Object不是设计来作为一种数据集合，因此没有有效的方法来确定对象具有多少属性(虽然有Object.keys，但是它很慢）。循环遍历对象的属性时，还会获得其原型属性。您可以将iterable属性添加到所有对象，但不是所有对象都可以用作集合。您可以使用for … in循环和hasOwnProperty（）方法，但这只是一种解决方法。循环访问对象的属性时，不一定按照插入的顺序检索属性。 Object具有内置方法，如constructor，toString和valueOf。如果其中一个作为属性添加，则可能导致冲突。虽然您可以使用Object.create(null)来创建一个裸对象（它不从object.prototype继承），但是这只是一个变通方法。 MDN对Map定义: Map对象保存键值对并记住键的原始插入顺序。任何值（对象和原始值）都可以用作键或值.其中key值的对比是基于一种类似于===操作符的算法，不过NaN被认为与自身相等（尽管JS中NaN!==NaN，因此Map中可以使用NaN作为key;&nbsp;Map中的键值对是有序的,因此在迭代时的顺序与插入时一致。 我们可以轻松创建Map，添加/删除值，迭代访问键/值并有效确定其大小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// new Map([iterable])let recipeMap = new Map([ ['Cucumber', '500 gr'], ['Tomatoes', '350 gr'],]);// Sets the value for the key in the Map object. Returns the Map object.recipeMap = recipeMap.set('Sour cream', '50 gr');// Returns a boolean asserting whether a value has been associated to the key in the Map object or not.console.log(recipeMap.has('Cucumber')); // true// loop by keysfor(let fruit of recipeMap.keys()) &#123; console.log(fruit); // Cucumber // Tomatoes // Sour cream&#125;// loop by values [key, value]for(let amount of recipeMap.values()) &#123; console.log(amount); // 500 gr // 350 gr // 50 gr&#125;// loop by recoedsfor(let entry of recipeMap) &#123; // same like recipeMap.entries() console.log(entry); // ["Cucumber", "500 gr"] // ["Tomatoes", "350 gr"] // ["Sour cream", "50 gr"]&#125;// Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.console.log(recipeMap.delete('paopaolee')); // false // Removes all key/value pairs from the Map object.recipeMap.clear(); // Returns the number of key/value pairs in the Map object.console.log(recipeMap.size === 0); // True SetMDN对Map定义: Set简单来说就是不包含重复项的值的有序集合，它允许您存储任何类型，无论是原始值还是对象引用，不像数组那样使用索引，Set使用Key访问集合。Set已经存在于Java，Ruby，Python和许多其他语言中。 ES6的Set与其他语言之间的一个区别在于ES6中的Set是有序的。 123456789101112131415161718const planetsOrderFromSun = new Set();planetsOrderFromSun.add('Mercury');planetsOrderFromSun.add('Venus').add('Earth').add('Mars'); // Chainable Methodconsole.log(planetsOrderFromSun.has('Earth')); // TrueplanetsOrderFromSun.delete('Mars');console.log(planetsOrderFromSun.has('Mars')); // Falsefor (const x of planetsOrderFromSun) &#123; console.log(x); // Same order in as out - Mercury Venus Earth&#125;console.log(planetsOrderFromSun.size); // 3planetsOrderFromSun.add('Venus'); // Trying to add a duplicateconsole.log(planetsOrderFromSun.size); // Still 3, Did not add the duplicateplanetsOrderFromSun.clear();console.log(planetsOrderFromSun.size); // 0 弱集合，内存和垃圾回收JavaScript垃圾回收机制是一种内存管理形式，可以自动删除不再引用的对象并回收其资源。 JS中，当一个对象被引用的时候，往往意味着它正在被使用，或者在将来有可能会被使用。此时对象所占用的内存不会被垃圾回收机制回收掉。Map和Set所引用的对象会被保留，不允许进行垃圾回收。如果Map和Set引用着不再需要的大对象（例如已经从DOM中删除的DOM元素），这可能会消耗大量内存。 &nbsp; 为了解决这个问题，ES6还引入了两个名为WeakMap和WeakSet的新弱集合。这些ES6集合是“弱”的，因为它们允许从内存中清除不再需要的对象。 &nbsp;弱引用则可以理解为“引用了对象，但是不影响它的垃圾回收”，举个🌰: 1234567var obj = &#123;&#125;;var wm = new WeakMap();wm.set(obj, 1);wm.get(obj); // 1......obj = null;wm.get(obj); // 这句没有意义 在这个例子中，WeakMap实例wm（弱）引用了obj对象（空对象），接着下方代码释放了对空对象的引用（obj = null），此时和上例一样，空对象将被垃圾回收。也即wm中持有的空对象（弱）引用并不影响对对象本身的垃圾回收。这就是WeakMap中“弱引用”的含义。 WeakMapMDN对Map定义: WeakMap是一种弱引用key的键值对（key/value）集合，其键（key）必须是一个对象，值（value）可以为任意类型。正由于这样的弱引用，WeakMap的key是无法枚举的 (即无法列举所有的key)。如果key是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。所以无法使用for…in或者for…of等语句迭代。 WeakMap使用场景&nbsp;WeakMaps有几个流行的用例。它们可用于保持对象的私有数据私有化，它们还可用于跟踪DOM节点/对象。 场景一使用WeakMap简化了保持对象数据私有的过程。privateData可以引用Person对象，但不允许在没有特定Person实例的情况下访问，而且随Person实例对象的销毁而消失。 123456789101112var Person = (function() &#123; var privateData = new WeakMap(); function Person(name) &#123; privateData.set(this, &#123; name: name &#125;); &#125; Person.prototype.getName = function() &#123; return privateData.get(this).name; // 只能通过Person实例访问对应的name &#125;; return Person();&#125;()); 场景二使用WeakMap处理事件绑定,在React中如果用到事件监听处理，通常我们必须要在对应的生命周期中相应的进行事件绑定或解除，以防止内存泄漏。然而如果使用WeakMap，我可以不用担心这些问题。 123456789101112131415161718192021222324var listeners = new WeakMap();// 监听事件function on(object, event, fn)&#123; var thisListeners = listeners.get(object); if(!thisListeners) thisListeners = &#123;&#125;; if(!thisListeners[event]) thisListeners[event] = []; thisListeners[event].push(fn); listeners.set(object, thisListeners);&#125;// 触发事件function emit(object, event)&#123; var thisListeners = listeners.get(object); if(!thisListeners) thisListeners = &#123;&#125;; if(!thisListeners[event]) thisListeners[event] = []; thisListeners[event].forEach(function(fn)&#123; fn.call(object, event); &#125;);&#125;// 使用var obj = &#123;&#125;;on(obj, 'hello', function()&#123; console.log('hello');&#125;);emit(obj, 'hello'); 场景三使用WeakMap跟踪DOM节点编辑，删除和更改。例如，Google的Polymer项目在一段名为PositionWalker的代码中使用了WeakMap PositionWalker keeps track of a position within a DOM subtree, as a current node and an offset within that node. 12345678910111213141516171819202122_makeClone() &#123; this._containerClone = this.container.cloneNode(true); this._cloneToNodes = new WeakMap(); this._nodesToClones = new WeakMap(); ... let n = this.container; let c = this._containerClone; // find the currentNode's clone while (n !== null) &#123; if (n === this.currentNode) &#123; this._currentNodeClone = c; &#125; this._cloneToNodes.set(c, n); this._nodesToClones.set(n, c); n = iterator.nextNode(); c = cloneIterator.nextNode(); &#125;&#125; WeakSetMDN对Map定义: WeakSet是弱引用的Set，当不再需要它们引用的对象时，它们的元素可以被垃圾收集。 WeakSet不允许迭代。 123456789101112var ws = new WeakSet();var foo = &#123;&#125;;var bar = &#123;&#125;;ws.add(foo);ws.add(bar);ws.has(foo); // truews.has(bar); // truews.delete(foo); // removes foo from the setws.has(foo); // false, foo has been removed WeakSet使用场景WeakSet使用场景相当有限（至少目前为止）。大多数早期采用者都说WeakSet可用于标记对象而不会改变它们。ES6-Features.org有一个添加和删除WeakSet中元素的示例，以便跟踪对象是否已被标记: 12345678910111213141516171819202122232425262728293031323334353637let isMarked = new WeakSet()let attachedData = new WeakMap()export class Node&#123; constructor(id)&#123; this.id = id; &#125; mark()&#123; isMarked.add(this); &#125; unmark()&#123; isMarked.delete(this); &#125; marked()&#123; return isMarked.has(this); &#125; set data(data)&#123; attachedData.set(this, data); &#125; get data()&#123; return attachedData.get(this); &#125;&#125;let foo = new Node("foo")JSON.stringify(foo) === '&#123;"id":"foo"&#125;'foo.mark()foo.data = "bar"foo.data === "bar"JSON.stringify(foo) === '&#123;"id":"foo"&#125;'isMarked.has(foo) === trueattachedData.has(foo) === truefoo = null /* remove only reference to foo */attachedData.has(foo) === falseisMarked.has(foo) === false 参考文章 ES6 Collections: Using Map, Set, WeakMap, WeakSet ES2015 WeakMap的学习和使用 JavaScript (ES-2015) Set, Map, WeakSet and WeakMap V8: Optimizing hash tables: hiding the hash code]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JS</tag>
        <tag>Map</tag>
        <tag>Set</tag>
        <tag>WeakMap</tag>
        <tag>WeakSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈Web--JWT]]></title>
    <url>%2Fweb%2FLP20190709A%2F</url>
    <content type="text"><![CDATA[“The most amazing achievement of the computer software industry is its continuing cancellation of the steady and staggering gains made by the computer hardware industry.” —Henry Petroski 前言随着技术的发展，分布式web应用的普及，通过session管理用户登录状态成本越来越高，因此慢慢发展成为token的方式做登录身份校验，然后通过token去取redis中的缓存的用户信息，随着之后jwt的出现，校验方式更加简单便捷化，无需通过redis缓存，而是所有数据都保存在客户端，每次请求都发回服务器，随后服务器直接根据token取出保存的用户信息，以及对token可用性校验，单点登录更为简单。 这篇文章中主要讲解了关于JSON Web Tokens（JWT）的基础概念，以及解释JWT为什么会被广泛应用。JWT是确保应用程序信任和安全的重要部分，它允许以诸如用户数据之类的安全的方式声明表示。 为了JWT的工作原理，我们先来看一看关于它的抽象定义： JSON Web Token（JWT）是一种JSON对象，在RFC 7519中定义为表示双方之间的一组信息的安全方式；它由头部、有效负载和签名三部分组成。 我们完全可以把JWT简单地看成仅仅是符合以下格式的字符串 header.payload.signature Notes: 合法的JSON必须是使用双引号的字符串 为了理解JWT是如何被使用的，我们将使用User（用户）、Application Server（应用服务器）、Authentication Server（授权服务器）3个简单的实体加以解释说明。其中Authentication Server将提供JWT给用户，用户拿到JWT后就可以和应用（app/website）安全地通信。 上图中，User携带用户名/密码等可证明身份的内容去授权服务器获取JWT信息，每次服务都携带该Token内容与应用服务器进行交互，由应用服务器来验证Token是否是授权系统发放的有效Token，来验证当前业务是否请求是否合法。 接下来我们深入理解JWT是如何构造以及如何验证的。 第一步 创建头部（header）JWT的头部包含了JWT自身的签名算法信息，它是一个具有如下格式的JSON对象： 1234&#123; "typ": "JWT", "alg": "HS256"&#125; 这个JSON中, typ属性表示令牌的类型，JWT令牌统一写为JWT。alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256） 第二部 创建有效载荷（payload）JWT的有效载荷即是JWT的主体内容部分,包含了需要传递的数据（这些数据也被称为JWT的声明）。在我们的🌰中，JWT中存储了用户ID信息。 123&#123; "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"&#125; 上面的🌰中，我们的JWT仅仅存储了一个信息。然而JWT 规定了7个官方字段，供选用 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 当然除了官方字段，你还可以在这个部分定义私有字段，诸如： 12345&#123; "sub": "1234567890", "name": "John Doe", "admin": true&#125; 值得注意的是有效载荷的存储数据的大小会影响整个JWT的大小，一般来说对JWT的大小没有限制但是过大的JWT可能会影响性能或造成潜在的问题。 第三步 创建签名（signature）签名是为了防止数据被篡改。 JWT的签名使用以下伪代码实现： 1234// signature algorithmdata = base64urlEncode( header ) + “.” + base64urlEncode( payload )hashedData = hash( data, secret )signature = base64urlEncode( hashedData ) 该算法所做的使用base64urlEncode对在第一步创建的头部和第二部中的有效负载分别进行编码并用”.”号拼接成字符串。随后使用JWT头中指定的散列算法对字符串使用密钥进行散列。最后再使用base64urlEncode对生成的散列数据进行编码以产生JWT签名。（密钥只有服务器才知道，不能泄露给用户） 这篇文章中，使用base64urlEncode对header和payload进行编码后得到如下结果： 1234567891011// headerbase64urlEncode(&#123; "typ": "JWT", "alg": "HS256"&#125;)eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9// payload// base64urlEncode(&#123; "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"&#125;)eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ 然后将结果代入上面的伪代码会得到如下签名： 12// signature-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM 第四步 生成JWT现在我们已经创建完成了JWT的header、payload、signature3个部分，那么再按照 header.payload.signature 的格式将3个部分组合起来就是所谓的JWT了。如下就是我们🌰中的JWT 12// JWTeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM 在JWT官方网站，你可以尝试创建自己的JWT。 回到我们的案例，这个Authentication Server 已经创建了一个JWT，并且发给了用户。 JWT是怎么保护数据的注意，这里经常会有一个误区，JWT本身和安全没关系，它就仅仅只是一个字符串，使用它来做安全远不如类似于RSA2这样的非对称加密的形式来的实在，由于客户端的程序对用户几乎完全透明，验签的过程对于他们来讲也是透明的，所以安全性肯定不会靠这个来实现，如果实在怕JWT的被盗取，可以考虑在Payload部分加入一些客户端独有的非敏感信息，用于在服务端来进行核验，比如使用MAC-Message Authentication Code、或者公钥之类的等等; 或者干脆就把生效时间设置的短一些，也可以减少暴露的风险。 JWT的数据被编码和被签名，但是没有被加密。编码的目的是转化数据结构，签名是为了数据的接收者验证数据的权威性。所以编码和签名并不会保护数据的安全性。而加密的主要目的才是为了保护数据安全防止未授权访问。对于详细描述编码与加密的区别，可以参考这篇文章。 Since JWT are signed and encoded only, and since JWT are not encrypted, JWT do not guarantee any security for sensitive data. 由于JWT仅仅被编码和签名而没有被加密过的，所以它无法保证任何敏感信息的安全性。 第五步 验证JWT第四步中我们已经知道JWT的签名生成需要用密钥（secret），这个密钥只有授权服务器知道。应与服务器开启认证处理时，需要从授权服务器获取此密钥。此后当用户携带JWT访问应用服务器时，应用服务器拿到JWT后可以通过类似第三步的方法生成一个签名，然后与用户携带的JWT的签名进行对比从而验证用户JWT是否有效。 结束语本文中描述的JWT认证设置使用对称密钥算法（HS256）。您也可以使用非对称算法（例如RS256），即授权服务器具有密钥，并且应用程序服务器具有公钥。了解使用对称和非对称算法之间差异的详细分类。 还应该注意，JWT应该通过HTTPS连接（而不是HTTP）发送。HTTPS有助于防止未经授权的用户窃取所发送的JWT，从而无法拦截服务器和用户之间的通信。 同时，JWT应该设置有效期，并且有效期不要太长。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶--bind函数]]></title>
    <url>%2Fweb%2FLP20190705A%2F</url>
    <content type="text"><![CDATA[“Programmers are in a race with the Universe to create bigger and better idiot-proof programs, while the Universe is trying to create bigger and better idiots. So far the Universe is winning.” —Rich Cook 官方描述首先我们先来看看MDN上对于bind函数的定义，主要有三个特点: bind函数会创建一个新函数（称为绑定函数），新函数与原函数具有相同的函数体（在 ECMAScript 5 规范中内置的call属性） 当生成的新函数被调用执行时，其this值始终指向bind函数的第一个参数且无法改变 bin函数可以接受预设的参数，该参数最终提供给原函数 新函数也能使用new操作符创建对象,这种行为就像把原函数当成构造器。提供的 this值被忽略，同时调用时的参数被提供给模拟函数 用例说明众所周知，JS中函数(ES6箭头函数除外)的this指向是在函数执行时动态绑定的，函数定义和实际运行时的所处的环境不一样，往往导致未知的bug。 尤其是在React组件中，经常会由于this指向问题导致无法调用到函数，所以通常我们会在constructor函数中使用bind函数来绑定this(当然一般我们都会使用箭头函数来避免此类情况)。 123456789101112131415var name = "paopaolee"function test()&#123; console.log(this.name)&#125;var obj = &#123; name: "lepaopao", print: test,&#125;test(); // paopaoleeobj.print(); // lepaopaovar obj1 = &#123; name: 'xxxxxx', print: test.bind(this) // 返回了一个新函数并且this指向window&#125;obj1.print(); // paopaolee 动手实现第一版目标：实现描述中的特征1、2、3 分析：返回的结果是一个函数；新函数调用时this指向第一个参数， 可以通过call/apply函数解决，call/apply函数的区别在于参数传递，前者需逐一列出，后者可以传递数组；bind函数可接受预设参数最终提供原函数，由于参数不确定，所以选用apply实现。 实现： 12345678Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var self = this; //普通调用时， this指向bind调用者 var args = slice(arguments, 1); return function () &#123; self.apply(Othat, args); &#125;&#125; 第二版问题：第一版中初步实现了前三个特征，当然还有诸多问题，例如如果新函数执行时需要有返回值、第一版中实现了绑定时传参，那新函数调用时传参数呢？以及bind函数调用不正确等等。 优化： 1234567891011121314Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); return function () &#123; // 解决: 新函数执行时return返回值 return self.apply(Othat, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125;&#125; 第三版目标： 解决bind函数的第三个特征: 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说bind执行返回的新函数作为构造函数执行时，bind时指定的对象(参数Othat)会失效，但是传入的参数依然有效。 举个🌰： 123456789101112131415161718var vaule = 2var obj = &#123; value: 1&#125;function female(name, age)&#123; this.favorite = 'shopping'; console.log(this.value); console.log(name, age);&#125;female.prototype.husband = 'leepaopao';var boundFunc = female.bind(obj, 'paopaolee');var p = new bindedFunc(23);// undefined// paopaolee 23consple.log(p.habit); // shoppingconsple.log(p.husband); // leepaopao 尽管在window以及obj中都声明了value值，但最终(this.value)依然返回了undefined，说明此时this即不指向window也不指向obj，bind时绑定的this（obj）失效了。所以此时this真正指向的是female的实例。 分析： 要判断新函数调用时是否为new构造函数调用，可以通过this是否为新函数的实例,所以我们把返回的匿名函数换成具名函数，以便判断。 实现 1234567891011121314151617Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; return boundFunc;&#125; 第四版问题： 第三版中，我们解决了bind函数的第4个特征，但是使用new操作符创建对象时，this指向的是boundFunc的实例，无法继承原函数的原型中的属性，原型链遭到破坏。 目标：重塑原型链 实现： 123456789101112131415161718Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; boundFunc.prototype = this.portotype; return boundFunc;&#125; 上述代码，重塑原型链的做法是直接将boundFunc.prototype = this.prototype，相当于直接用原函数的prototype覆盖掉了boundFunc函数原来的prototype，这样如果我们更改boundFunc.prototype中的属性是也会影响原函数的prototype上的属性。 最终版12345678910111213141516171819202122232425Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; // 重塑原型链: 方法一 boundFunc.prototype = Object.create(this.portotype); // 重塑原型链: 方法二 /**** function fNOP ()&#123;&#125; fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); ****/ return boundFunc;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶--Iterator and Generator]]></title>
    <url>%2FWeb%2FLP20180917A%2F</url>
    <content type="text"><![CDATA[“The best programmers are not marginally better than merely good ones. They are an order-of-magnitude better, measured by whatever standard: conceptual creativity, speed, ingenuity of design, or problem-solving ability.” —Randall E. Stross 前言大多数编程语言已经从使用for循环（需要初始化变量以便跟踪数据在集合中的位置）转而使用以编程方式返回集合中下一项的迭代器对象来迭代数据。 尽管迭代器使得处理数据集合更加容易,但是由于需要显式地维护其内部状态，因此它们的创建需要谨慎的编程。生成器函数提供了一个强大的选择：它们允许您通过编写一个执行不连续的函数来定义迭代算法。 循环问题如果你使用JavaScript(ES5)来编写过程序，那你很可能写类似一下子的代码： 1234var colors = ["red", "green", "blue"];for(var i = 0; i &lt; colors.length; i++)&#123; console.log(colord[i]);&#125; 这种标准的for循环中，使用变量i来追踪colors数组的索引位置，变量i的值会随着每次迭代而递增直到它大于数组的长度值。虽然上面的循环十分简单，但是当你嵌套循环并且需要跟踪多个变量时，循环会变得复杂。额外的复杂性可能导致错误，并且for循环的样板性质会导致更多错误，因为类似的代码写在多个地方。而迭代器旨在解决这些问题。 可迭代协议众所周知，在JavaScript中遍历数组中的每一个元素是一件很简单的事情，我们可以通过最原始的for、while循环，或ES6为我们提供的for-of之类的众多方法来实现。但是在实际编程工作中，我们除了会使用数组这样的数据结构之外，还会大量使用自定义数据结构，那么我们如何去遍历或者说使这些自定义数据结构能够被循环迭代呢？可迭代协议允许JavaScript对象定义或自定义其迭代行为，例如在for..of构造中循环的值；为了实现可迭代性，对象(或其原型上)必须实现Symbol.iterator方法，该方法返回一个叫做迭代器的对象。 实现123456789101112131415161718192021222324252627const iterable = &#123; [Symbol.iterator]()&#123; let step = 0; const iterator = &#123; next()&#123; if(step &lt; 3)&#123; step++; return (&#123; value: step, done: false, &#125;); &#125; return &#123; value: step, done: true, &#125; &#125; &#125;; return iterator; &#125;&#125;;const iterator = iterable[Symbol.iterator]();iterator.next() // &#123;value: 1, done: false&#125;iterator.next() // &#123;value: 2, done: false&#125;iterator.next() // &#123;value: 3, done: false&#125;iterator.next() // &#123;value: 3, done: true&#125; 应用JavaScript中一些内置数据类型是具有默认迭代行为的内置可迭代类型，例如String、Array、Mapy及Set，因为它们的原型上实现了[Symbol.iterator]方法。当然还有很多地方使用了可迭代性，有的可能不太明显，比如： for-of循环 数组结构 ES6扩展运算符 Map和Set的构造函数要求是可迭代对象Iterator（迭代器）定义MDN定义： 迭代器仅仅是具有为迭代设计的特定接口的对象。所有的迭代器对象都有一个“next()”方法,这个方法返回一个含有value和done两个字段的对象，其中value字段的值就是当前从数据集合中迭代出的值；而done字段的是一个布尔值，用来表示迭代是否已经完成。迭代器一旦被创建， 我们就能通过重复调用“next()”方法来迭代它，在产生终止值后继续调用next()方法应该始终返回{done: true} 案例123456789101112131415161718192021222324252627282930function makeRangeIterator&lt;T&gt;(dataCollection: Array&lt;T&gt;, start=0, step=1,end=Infinity,)&#123; const len = dataCollection.length; let nextIndex = start; let iterationValue: T; return &#123; next: function (param?: any): &#123;value: T, done: boolean&#125; &#123; if(nextIndex &lt; end &amp;&amp; nextIndex &lt; len)&#123; iterationValue = dataCollection[nextIndex]; nextIndex += step; return &#123; value: iterationValue, done: false, &#125; &#125; return &#123; value: iterationValue, done: true, &#125; &#125; &#125;&#125;var iterator = makeRangeIterator(["s",3,&#123;name: 'paopaolee'&#125;],0,1,3);console.log(JSON.stringify(iterator.next())); // &#123;"value":"s","done":false&#125;console.log(JSON.stringify(iterator.next()));// &#123;"value":3,"done":false&#125;console.log(JSON.stringify(iterator.next()));// &#123;"value":&#123;"name":"paopaolee"&#125;,"done":false&#125;console.log(JSON.stringify(iterator.next()));// &#123;"value":&#123;"name":"paopaolee"&#125;,"done":false&#125; 下面这张图可以帮组我们建立可迭代性、迭代器、next之间的关系： Generator（生成器）虽然自定义迭代器是一个十分有用的工具，但是从上面代码可以看出由于需要去显示维护其内部状态，所以创建迭代器需要谨慎的编程。生成器是一个强有力的替代工具，它使得我们可以更简单的创建迭代器对象。 定义MDN定义: 生成器是一个返回迭代器的函数，它允许通过编写一个非连续执行的函数来定义迭代算法。它的的语法为“function* FuncName(){ }”。首次调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。通过调用生成器的“next”方法消耗值时，Generator函数将执行，直到遇到yield关键字。 简而言之，JavaScript中生成器是一个返回值为迭代器的函数，与普通函数不同的是，生成器函数在执行过程中可以中断并且能从中断的地方继续执行。下面的这张图对比了普通函数与生成器函数执行过程： 举例说明123456789101112131415function* generatorFunction()&#123; // line 1 console.log('This will be executed first.') yield 'Hello,'; // line 2 console.log('Iwill be printed after the pause.'); yield 'World!'; &#125;const generatorObject = generatorFunction(); // line 3console.log(generatorObject.next().value); // line 4// This will be executed first.// Hello, console.log(generatorObject.next().value); // line 5// I will be printed after the pause// World!console.log(generatorObject.next().value); // line 6// undefined 上面代码中，我们使用了function* 的语法创建了一个生成器函数（line 1），在函数内部我们使用了另一个关键字yield（line 2），它只能在生成器中使用。生成器函数在执行过程中一旦运行到yield关键字时，会立即“返回”定义在它后面的值并中断函数的执行，注意此处的返回跟普通函数的return不同，在生成器上下文中，我们叫（yield）产出某值。 12345function * generatorFunc() &#123; yield 'a'; return 'b'; // Generator ends here. yield 'a'; // Will never be executed. &#125; 在（line 3）中我们通过创建了generatorObject对象，这看起来貌似生成器函数“generatorFunction”内部的语句应该已经执行，但是神奇的是第一句console.log为啥并没有打印输出呢？原来是，当生成器函数执行时总是简单的返回一个迭代器对象，然后通过调用这个迭代器对象的next方法，生成器函数内部语句才会开始执行； 所以（line 3 中）generatorObject就是一个迭代器对象，然后我们通过调用它的next方法（line 4）,这时生成器“generatorFunction”才开始真正执行，打印出”This will be executed first.“；接着执行下一行代码（line 2），这时遇到了yield关键值，将其后定义的‘Hello’字符串作为值，产出“{value: ‘Hello’, done: false}”对象,同时会被暂时中断挂起，直到迭代器再次调用next方法； 在line 5中，我们再次调用了next，这时生成器函数被唤醒并从上一次挂起的地方继续开始执行，所以打印出”I will be printed after the pause“，接着又遇到了yield关键字，产出”{value: ‘World！’, done: false}”后再次挂起； 在line 5中，我们又再一次调用了next，这次生成器函数被唤醒后发现没有语句可以执行了，记住如果函数没有return语句，默认返回undefined,因此生成器函数会产出”{value: undefined, done: true}”,属性值done被设置为true，这就意味着生成器函数执行结束了。 应用场景一 . 实现可迭代前面有提到要实现可迭代性，对象(或其原型上)必须实现[Symbol.iterator]方法来返回一个我们自己编写的迭代器，这使得实现过于复杂，而生成器函数可以使我们更简单的创建迭代器对象。接下来我们分别使用自定义迭代器和生成器来实现可迭代行对象。自定义迭代器： 12345678910111213141516171819const iterableObj = &#123; [Symbol.iterator]: () =&gt; &#123; let step = 0; return &#123; next: () =&gt; &#123; step++; if (step === 1) &#123; return &#123; value: 'This', done: false&#125;; &#125; else if (step === 2) &#123; return &#123; value: 'is', done: false&#125;; &#125; else if (step === 3) &#123; return &#123; value: 'iterable.', done: false&#125;; &#125; return &#123; value: '', done: true &#125;; &#125; &#125;; &#125;&#125;;[...iterableObj] // ["This", "is", "iterable."] 生成器 1234567function * generatorFunc() &#123; yield 'This'; yield 'is'; yield 'iterable.'&#125;const iterableObj = generatorFunc();[...iterableObj] // ["This", "is", "iterable."] 你可以比较两个版本，它可以说明生成器带来的诸多好处： 我们不需要关心Symbol.iterator 我们不再必须实现next方法 我们不再关心必须像在next方法中返回{value: ‘This’, done: false}这样的对象结构 我们不用去维护迭代器内部的状态 二. 异步任务处理生成器最让人兴奋的地方与异步编程相关。 JavaScript中的异步编程是一把双刃剑：简单的异步任务很容易完成，而复杂的异步任务成为代码组织的一个苦差事。然而生成器允许您在执行过程中有效地暂停代码，因此它们开辟了许多与异步处理相关的可能性。 解决异步任务的传统方法是回调函数，这种方法能够很好地解决简单的业务，但是一旦业务过于复杂，这种方法往往使得嵌套多层代码造成回调地狱。得益于yield关键字可以中断挂起函数直到next方法的调用，我们可以不需要管理回调函数就能实现异步编程。 高级迭代器功能传递参数到迭代器在上述迭代器的案例代码中可以发现，迭代器的next方法其实可以接受参数。在生成器函数中，将参数传递给next（）方法时，该参数将成为生成器内yield语句的值。此功能对于更高级的功能（如异步编程）非常重要。这是一个基本的例子： 123456789101112131415function * createIterator()&#123; let first = yield 1; // line 1 let seccond = yield first + 2; // line 2 yield second + 3; // line 3&#125;const iterator = createIterator();console.log(iterator.next()); // line 4// "&#123; value: 1, done: false &#125;"console.log(iterator.next(4)); // line 5// "&#123; value: 6, done: false &#125;"console.log(iterator.next(5)); // line 6 // "&#123; value: 8, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 上面代码中，我们在第一次调用next方法时（line 4），生成器函数内部开始执行（line 1），执行过程中由于赋值语句是从右往左执行的，一开始就遇到yield关键值，产出”{value: 1, done: flase}”,然后中止挂起函数等待下一次next方法调用，注意此时变量first还没有被赋值；当我们再次调用（line 5）next方法（值得注意的是，此次调用next方法时还传入了参数4），函数从上一次中止的地方（line 1 表达式右边）被唤醒继续执行，此时参数4会被当作yield语句的执行结果赋值给变量first，接着执行下一行（line 2）直到遇到yield，产出”{value: 6(4+2), done: false}”然后中止；继续我们第三次调用next（line 6），这次yield接受参数5赋给变量second，产出”{value: 8(5+3), done: false}”后再次中断挂起；最后一次调用next，函数被唤醒后发现没有语句可以执行，且函数没有return语句（即默认返回undefined），所以默认返回”{value: undefined, done: true}”; 注意，首次调用next方法传入的参数是无效的，会被函数完全忽略掉。即上面(line 4)代码中的next函数中传入任何参数都是无效的。 在生成器中抛出和捕获错误我们通过迭代器的next方法不仅能传递数据，而且还能传递Error信息。迭代器可以选择实现一个throw（）方法，该方法指示迭代器在恢复时抛出错误。 function * createIterator(){ let first = yield 1; // line 1 let seccond； try{ second = yield first + 2; }catch(error){ second = 6; } yield second + 3; // line 3 } let iterator = createIterator(); console.log(iterator.next()); // "{ value: 1, done: false }" console.log(iterator.next(4)); // "{ value: 6, done: false }" console.log(iterator.throw(new Error("Boom"))); // "{ value: 9, done: false }" console.log(iterator.next()); // "{ value: undefined, done: true 在生成器函数中使用return语句我们说过生成器就是一个函数，我们可以像普通函数那样在生成器中使用return语句，它默认会将返回值中的done属性设置为true，也就意味着你可以通过使用return语句提前退出函数或为定义最后一次调用next方法的产出值。 function * createIterator(){ let first = yield 1; // line 1 let seccond = yield first + 2; // line 2 return 1000; yield second + 3; // line 3 } 上面代码中，第三次调用next方法后，产出值为”{value: 1000, done: true}”,并且函数会退出。 特殊地，ES6中的扩展运算符和for-of操作符会忽略掉任何return语句定义的值。因为它们首先检查对象中的done属性是否为true，一旦done为true便不会在读取value属性。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
