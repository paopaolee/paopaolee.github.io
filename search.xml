<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[译]Web视频播放原理：介绍]]></title>
    <url>%2Fweb%2FLP20190706A%2F</url>
    <content type="text"><![CDATA[原文: How video streaming works on the web: An introduction 渴求原生视频API从2000年代早期到晚期，网络上的视频播放主要依赖于Flash插件。这是因为在那个时候，浏览器中没有实现其他的视频流播放方案。用户如果想要在网页中播放视频，只能通过安装第三方插件，比如flash或者silverlight，来播放视频，否则根本无法观看视频。 为了填写这一空白，网页超文本应用技术工作小组（WHATWG）开始着手制订新版本的HTML标准，其中就包括原生视频和音频（无需插件）播放。这个新版本的HTML标准就是大家熟知的HTML5. 于是HTML5给web开发带来&lt;Video&gt;标签，这个新标签允许开发者直接通过HTML加载视频资源，类似于通过&lt;img&gt;标签加载图片资源。这个一个很酷的事情，但是从媒体网站的角度看来，这种类似图片加载的方式似乎不足以取代flash，原因如下： 用户可能需要在多个质量视频间进行即时切换 直播是另一个使用场景，看起来很难以这种方式实现 如果内容像Netflix一样流式传输，那么基于用户偏好更新内容的音频语言呢？ 值得庆幸的是，随着HTML5规范的到来，以上所有这些问题都可以在大多数浏览器上解决。本文将详细介绍今天的web如何做到这些的。 Video标签前面有提到，使用HTML5在网页里加载视频是相当直观，你只需要在你的页面中添加一个video标签以及给它一些相关的属性。 123456789&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;My Video&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;video src="some_video.mp4" width="1280px" height="720px" /&gt; &lt;/body&gt;&lt;/html&gt; video标签将允许您的页面直接在任何支持相应编解码器（当然还有HTML5）的浏览器上流式传输some_video.mp4。同时HTML5还提供了丰富的API，比如视频的播放，暂停，快进以及改变播放速率。 然而，现如今我们在网站上看到的视频拥有更过更复杂的行为远远超过了HTML5提供给我们的。例如，视频质量切换和实时流媒体。这些网站实际上仍然使用视频标签。但是，他们不是简单地在src属性中设置视频地址，而是使用更强大的Web API，即媒体资源扩展（Media Source Extensions）。 媒体资源扩展（Media Source Extensions）媒体资源扩展（Media Source Extensions简称“MSE”， 是一个现今多数浏览器都遵守的规范。它创建来是为了让HTML和JavaScript允许那些复杂的媒体用例。 这些“扩展”将MediaSource对象添加到JavaScript，顾名思义，它就是视频资源，或者更简单地说，这是表示我们视频数据的对象。如上面所说，我们仍然会使用&lt;video&gt;, 也许更令人惊讶的是,我们仍然使用是src属性，只是我们不再链接到一个视频文件，而是链接到一个媒体资源对象。 你可能对而是链接到一个媒体资源对象感到很疑惑，这里我们不再说它是一个URL，而我们说它是一个JavaScript语言中的抽象概念，那怎么可以将它称为视频标签上的URL，这是在HTML中定义的？ 为了允许这种用例，W3C定义了URL.createObjectURL静态方法。此API允许创建一个URL，该URL实际上不会引用在线可用的资源，而是直接引用在客户端上创建的JavaScript对象。这就是MediaSource附加到视频标签的原理。 12345678const videoTag = document.getElementById("my-video");// creating the MediaSource, just with the "new" keyword, and the URL for itconst myMediaSource = new MediaSource();const url = URL.createObjectURL(myMediaSource);// attaching the MediaSource to the video tagvideoTag.src = url; 就是这样！现在你知道流媒体平台如何在网络上播放视频了！ 开个玩笑。所以现在我们有了MediaSource，但是我们应该怎么做呢？ MSE规范并不止于此。它还定义了另一个概念SourceBuffers。 资源缓冲视频实际上并未直接“推入”MediaSource进行播放，SourceBuffer用于此目的。 一个MediaSource包含一个或多个SourceBuffer实例。每个都与某一种类型内容相关联。这里简单地说，有三种可能的类型： audio video audio 和 video 注意： 实际上，内容的“类型”由其MIME类型定义，其还可以包括关于所使用的媒体编解码器的信息 SourceBuffer都会链接到单个MediaSource，其中每个SourceBuffer都会被JavaScript用来将视频数据直接添加到HTML5视频标签。如下图所示： 分离视频和音频还允许在服务器端单独管理它们。这样做会带来一些好处，我们稍后会看到。这是它的工作原理： 12345678910111213141516171819202122232425262728// -- 创建MediaSource并关联到video --const videoTag = document.getElementById("my-video");const myMediaSource = new MediaSource();const url = URL.createObjectURL(myMediaSource);videoTag.src = url;// 1. 为MediaSource添加sourceBufferconst audioSourceBuffer = myMediaSource .addSourceBuffer(`audio/mp4; codecs="mp4a.40.2"`);const videoSourceBuffer = myMediaSource .addSourceBuffer(`video/mp4; codecs="avc1.64001e"`);// 2. 下载并添加audio/video到SourceBuffers// for the audio SourceBufferfetch("http://server.com/audio.mp4").then(function(response) &#123; // The data has to be a JavaScript ArrayBuffer return response.arrayBuffer();&#125;).then(function(audioData) &#123; audioSourceBuffer.appendBuffer(audioData);&#125;);// the same for the video SourceBufferfetch("http://server.com/video.mp4").then(function(response) &#123; // The data has to be a JavaScript ArrayBuffer return response.arrayBuffer();&#125;).then(function(videoData) &#123; videoSourceBuffer.appendBuffer(videoData);&#125;); 我们现在能够动态地将视频和音频数据添加到我们的视频标签中。 现在是时候介绍音频和视频数据了。在前面的示例中，您可能已经注意到音频和视频数据采用mp4格式。 “mp4”是一种容器格式，它不仅包含相关的媒体数据，还包含多个元数据，例如，它所包含的媒体的开始时间和持续时间。。 MSE规范没有规定浏览器必须理解哪种格式。对于视频数据，最常见的两个是mp4和webm文件。前者现在非常有名，后者由谷歌赞助并基于可能更为人所知的Matroska格式（“.mkv”文件）。大多数浏览器对这两种格式都有很好的支持。 尽管如此，许多问题仍未得到解答： 我们是否必须等待下载整个内容，才能将其推送到SourceBuffer（因此能够播放）？ 我们如何在多种质量或语言之间切换 如何在媒体资源尚未完成时播放实况内容（即如何实现直播）？ 媒体片段在上面的代码中，我们有一个http://server.com/audio.mp4文件代表整个音频，一个http://server.com/vedio.mp4文件代表整个视频。这对于非常简单的用例来说已经足够了，但如果您想要了解大多数流媒体网站提供的复杂性（切换语言，质量，播放实时内容等），这还不够。 在更高级的视频播放器中实际发生的是, 音/视频数据被分成多个“片段”。这些段可以有各种大小，但它们通常代表2到10秒的内容。所有这些音/视频片段形成完整的音/视频内容。这些数据块为我们之前的示例增加了一个全新的灵活性：不是一次推送整个内容，我们可以逐步推动多个音/视频片段。 下面有一个简单的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...// (definition of the MediaSource and its SourceBuffers)/** * Fetch a video or an audio segment, * and returns it as an ArrayBuffer, in a Promise. * @param &#123;string&#125; url * @returns &#123;Promise.&lt;ArrayBuffer&gt;&#125; */function fetchSegment(url) &#123; return fetch(url).then(function(response) &#123; return response.arrayBuffer(); &#125;);&#125;// fetching audio segments one after another (notice the URLs)fetchSegment("http://server.com/audio/segment0.mp4") .then(function(audioSegment0) &#123; audioSourceBuffer.appendBuffer(audioSegment0); &#125;) .then(function() &#123; return fetchSegment("http://server.com/audio/segment1.mp4"); &#125;) .then(function(audioSegment1) &#123; audioSourceBuffer.appendBuffer(audioSegment1); &#125;) .then(function() &#123; return fetchSegment("http://server.com/audio/segment2.mp4"); &#125;) .then(function(audioSegment2) &#123; audioSourceBuffer.appendBuffer(audioSegment2); &#125;) // ...// same thing for video segmentsfetchSegment("http://server.com/video/segment0.mp4") .then(function(videoSegment0) &#123; videoSourceBuffer.appendBuffer(videoSegment0); &#125;);// ... 从上面代码可以看出，在服务器端存在多个片段资源: 123456./audio/ ├── segment0.mp4 ├── segment1.mp4 └── segment2.mp4./video/ └── segment0.mp4 ⚠️ 服务器端的音/视频文件可能并没有真正被分段，客户端可以使用HTTP range request来获取分段的那些文件片段（也有可能服务器真的可以根据您的请求发送你想要的备份片段）。但是，这些情况都是实现细节。本文中我们认为服务器端有分段。 所有这些都意味着，我们不必等待整个音/视频内容下载后才开始播放。我们经常只需媒体片段。当然，大多数播放器不会像我们代码那样为每个视频和音频片段手动执行此逻辑，但他们遵循相同的想法：按顺序下载片段并将其推入资源缓冲区（SourceBuffer）。 一种有趣的方式看到这个逻辑发生在现实生活中可以打开网络监视器在Firefox /铬/边缘(在Linux或windows类型“Ctrl + Shift + i”和“网络”选项卡,在Mac应该Cmd + Alt +然后我“网络”),然后启动一个视频在你最喜爱的流媒体网站。你应该会看到各种视频和音频片段被快速下载: 顺便说一下，您可能已经注意到，我们的段只是被推入源缓冲区，而没有根据时间位置指示应该推入的位置。片段的容器实际上定义了它们应该放在整个媒体中的时间。这样，我们就不必在JavaScript中同步它了。 自适应流媒体许多视频播放器都有“自动质量”功能，根据用户的网络和处理能力自动选择质量。这是自适应流媒体的网络播放器的核心。这种行为也是得益于媒体切片的概念。 在服务端，音/视频片段实际上是以多种质量编码的。例如，我们的服务器可以存放下面的文件： 123456789101112131415161718./audio/ ├── ./128kbps/ | ├── segment0.mp4 | ├── segment1.mp4 | └── segment2.mp4 └── ./320kbps/ ├── segment0.mp4 ├── segment1.mp4 └── segment2.mp4./video/ ├── ./240p/ | ├── segment0.mp4 | ├── segment1.mp4 | └── segment2.mp4 └── ./720p/ ├── segment0.mp4 ├── segment1.mp4 └── segment2.mp4 然后，Web播放器可以根据网络或CPU条件自动正确选择要下载的片段。这完全是用JavaScript完成的。对于音频片段，例如，它可能看起来像这样： 123456789101112131415161718192021222324252627282930313233343536/** * 根据片段的编号和质量推入sourceBuffer * @param &#123;number&#125; nb * @param &#123;string&#125; language * @param &#123;string&#125; wantedQuality * @returns &#123;Promise&#125; */function pushAudioSegment(nb, wantedQuality) &#123; // The url begins to be a little more complex here: const url = "http://my-server/audio/" + wantedQuality + "/segment" + nb + ".mp4");return fetch(url) .then((response) =&gt; response.arrayBuffer()); .then(function(arrayBuffer) &#123; audioSourceBuffer.appendBuffer(arrayBuffer); &#125;);&#125;/**将当前的带宽转换为对应音频服务器端定义的质量。 * @param &#123;number&#125; bandwidth * @returns &#123;string&#125; */function fromBandwidthToQuality(bandwidth) &#123; return bandwidth &gt; 320e3 ? "320kpbs" : "128kbps";&#125;// first estimate the bandwidth. Most often, this is based on// the time it took to download the last segmentsconst bandwidth = estimateBandwidth();const quality = fromBandwidthToQuality(bandwidth);pushAudioSegment(0, quality) .then(() =&gt; pushAudioSegment(1, quality)) .then(() =&gt; pushAudioSegment(2, quality)); 正如您所看到的，我们将不同质量的片段放在一起没有问题，javascript上的所有内容都是透明的。在任何情况下，容器文件包含足够的信息，使此过程能够顺利运行。 多语言切换在Netflix、Amazon Prime video或MyCanal等更复杂的网络视频播放器上，也可以根据用户设置在多种音频语言之间切换。既然您已经知道了视频质量的切换方式，那么多语言切换的实现方式对您来说应该非常简单。与自适应流媒体一样，我们在服务器端也有很多段： 12345678910111213./audio/ ├── ./esperanto/ | ├── segment0.mp4 | ├── segment1.mp4 | └── segment2.mp4 └── ./french/ ├── segment0.mp4 ├── segment1.mp4 └── segment2.mp4./video/ ├── segment0.mp4 ├── segment1.mp4 └── segment2.mp4 这一次，视频播放器切换语言不再是基于客户端功能，而是根据用户的偏好进行切换。对于音频段，客户端代码大致是以下样子: 12345678910111213141516171819202122232425// .../** * Push audio segment in the source buffer based on its number and language. * @param &#123;number&#125; nb * @param &#123;string&#125; language * @returns &#123;Promise&#125; */function pushAudioSegment(nb, language) &#123; // construct dynamically the URL of the segment // and push it to the SourceBuffer const url = "http://my-server/audio/" + language + "/segment" + nb + ".mp4" return fetch(url); .then((response) =&gt; response.arrayBuffer()); .then(function(arrayBuffer) &#123; audioSourceBuffer.appendBuffer(arrayBuffer); &#125;);&#125;// recuperate in some way the user's languageconst language = getUsersLanguage();pushAudioSegment(0, language) .then(() =&gt; pushAudioSegment(1, language)) .then(() =&gt; pushAudioSegment(2, language)); 您可能还希望在切换语言时“清除”以前的SourceBuffer内容，以避免混合使用多语言音频内容。这可以通过SourceBuffer.prototype.remove方法实现，该方法以秒为开始和结束时间： 12// remove pushed content from 0 to 40saudioSourceBuffer.remove(0, 40); 当然，也可以将自适应流媒体和多语言结合起来。我们可以将服务器的文件按照以下形式组织： 12345678910111213141516171819202122232425262728./audio/ ├── ./esperanto/ | ├── ./128kbps/ | | ├── segment0.mp4 | | ├── segment1.mp4 | | └── segment2.mp4 | └── ./320kbps/ | ├── segment0.mp4 | ├── segment1.mp4 | └── segment2.mp4 └── ./french/ ├── ./128kbps/ | ├── segment0.mp4 | ├── segment1.mp4 | └── segment2.mp4 └── ./320kbps/ ├── segment0.mp4 ├── segment1.mp4 └── segment2.mp4./video/ ├── ./240p/ | ├── segment0.mp4 | ├── segment1.mp4 | └── segment2.mp4 └── ./720p/ ├── segment0.mp4 ├── segment1.mp4 └── segment2.mp4 这样，客户端必须管理语言和网络条件： 12345678910111213141516171819202122232425/** * Push audio segment in the source buffer based on its number, language and quality * @param &#123;number&#125; nb * @param &#123;string&#125; language * @param &#123;string&#125; wantedQuality * @returns &#123;Promise&#125; */function pushAudioSegment(nb, language, wantedQuality) &#123; // The url begins to be a little more complex here: const url = "http://my-server/audio/" + language + "/" + wantedQuality + "/segment" + nb + ".mp4"); return fetch(url) .then((response) =&gt; response.arrayBuffer()); .then(function(arrayBuffer) &#123; audioSourceBuffer.appendBuffer(arrayBuffer); &#125;);&#125;const bandwidth = estimateBandwidth();const quality = fromBandwidthToQuality(bandwidth);const language = getUsersLanguage();pushAudioSegment(0, language, quality) .then(() =&gt; pushAudioSegment(1, language, quality)) .then(() =&gt; pushAudioSegment(2, language, quality)); 如您所见，现在有很多方法可以定义相同的内容。这揭示了分离视频和音频段相对于整个文件的另一个优势。对于后者，我们将不得不结合服务器端的所有可能性，这可能会占用更多的空间: 123456789101112131415161718192021222324segment0_video_240p_audio_esperanto_128kbps.mp4segment0_video_240p_audio_esperanto_320kbps.mp4segment0_video_240p_audio_french_128kbps.mp4segment0_video_240p_audio_french_320kbps.mp4segment0_video_720p_audio_esperanto_128kbps.mp4segment0_video_720p_audio_esperanto_320kbps.mp4segment0_video_720p_audio_french_128kbps.mp4segment0_video_720p_audio_french_320kbps.mp4segment1_video_240p_audio_esperanto_128kbps.mp4segment1_video_240p_audio_esperanto_320kbps.mp4segment1_video_240p_audio_french_128kbps.mp4segment1_video_240p_audio_french_320kbps.mp4segment1_video_720p_audio_esperanto_128kbps.mp4segment1_video_720p_audio_esperanto_320kbps.mp4segment1_video_720p_audio_french_128kbps.mp4segment1_video_720p_audio_french_320kbps.mp4segment2_video_240p_audio_esperanto_128kbps.mp4segment2_video_240p_audio_esperanto_320kbps.mp4segment2_video_240p_audio_french_128kbps.mp4segment2_video_240p_audio_french_320kbps.mp4segment2_video_720p_audio_esperanto_128kbps.mp4segment2_video_720p_audio_esperanto_320kbps.mp4segment2_video_720p_audio_french_128kbps.mp4segment2_video_720p_audio_french_320kbps.mp4 服务端需要存放更多的文件，显然这些文件数据存在大量冗余信息（完全相同的视频数据包含在多个文件中），并且这种方式这在客户端也有一个缺点，因为切换音频语言可能会导致您重新下载视频（具有高带宽成本）。 实况内容我们还没有谈论直播。网络直播变得非常普遍（例如twitch.tv，YouTube直播流…），而且由于我们的视频和音频文件是分段的，这又一次大大简化了。 为用最简单的方式解释直播的基本原理，让我们考虑一个刚刚在4秒前开始直播的YouTube频道。if我们的片段内容是2秒长，那么此时YouTube的服务器应该已经产生了两个音频片段和两个视频片段： 123456./audio/ ├── segment0s.mp4 └── segment2s.mp4./video/ ├── segment0s.mp4 └── segment2s.mp4 在直播开始的第5秒时，服务器此时还没有时间生成下一个段（第3个），所以服务器具有完全相同的可用内容。直到第6秒后，服务器产生了一个新的片段： 12345678./audio/ ├── segment0s.mp4 ├── segment2s.mp4 └── segment4s.mp4./video/ ├── segment0s.mp4 ├── segment2s.mp4 └── segment4s.mp4 这在服务器端是非常合乎逻辑的，直播内容实际上并不是真正意义上连续的，它们像非实时内容一样被分段，只是随着时间的推移，直播的片段继续逐渐出现。 那么，我们如何从JS知道在某个时间点上服务器上有哪些片段是可用的呢? 最简单的，我们可以客户端上使用计时器，用来推断新的片段在服务器端可用时的时间。我们将遵循“segmentX.mp4”命名模式，我们将每次从最后下载的一个增加“X”（segment0.mp4，然后，2秒后，Segment1.mp4等）。然而，在许多情况下，这可能变得并不精确： 媒体内容片段持续时间并不固定， 服务器在生成片段时有延迟， 服务器可能会为了节省空间而删除太旧的视频 作为客户端，您希望尽快请求最新的片段，一旦它们可以被获取；同时也要避免在尚未生成时过早地请求它们（这将导致404 HTTP错误）。 通常使用传输协议（有时也称为流媒体协议）来解决此问题。 传输协议对于本文来说，深入解释不同的传输协议可能过于冗长。让我们假设它们中的大多数都有相同的核心概念:Manifest。 Manifes是一个用来描述服务器上可用片段的文件。有了它，你可以描述在这篇文章中学到的大多数内容： 哪些音频语言的内容可用，以及它们在服务器上的位置（如“在哪个URL”） 可用的不同音/视频质量 当然，如果在直播环境下，包括可使用的片段 下面是一些Web中最常使用的传输协议： DASH YouTube，Netflix以及Amazon Prime Video等都在使用。 DASH的Manifest基于XML，被称为媒体呈现描述（或MPD）。 DASH规范具有很大的灵活性，允许MPD支持大多数用例(音频描述、父级控件)，并且不依赖于编码。 HLS 由Apple开发，使用者包括DailyMotion，Twitch.tv等。 HLS的Manifest称为播放列表，其文件格式为m3u8 (m3u播放列表文件，用UTF-8编码)。 Smooth Streaming 由微软开发，被多个微软产品和MyCanal使用。在Smooth Streaming的Manifest是基于xml的。 真实的网络世界如您所见，web视频背后的核心概念在于用JavaScript动态推送的媒体片段。这种行为很快变得相当复杂，因为视频播放器需要支持很多功能: 下载并解析某种Manifest文件 监测当前的网络状况 用户首选项(例如，首选语言) 知道下载哪个部分，这至少取决于前面的两点 管理一个段管道，以便在正确的时间顺序下载正确的段(同时下载每个段将是低效的:您需要最早的一个段，而不是下一个) 处理字幕，通常完全用JS管理 一些视频播放器还管理一个缩略图跟踪，您可以经常看到，当悬停在进度条 许多服务还需要DRM管理 还有很多其他的… 尽管如此，复杂的web兼容视频播放器仍然基于MediaSource和sourcebuffer。这就是为什么这些任务通常是由库执行的，库就是这样做的。通常，这些库甚至不定义用户界面。它们大多提供丰富的api，将Manifest和各种首选项作为参数，并在正确的源缓冲区的正确时间推送正确的片段。 这使得在设计媒体网站和web应用程序时具有更大的模块化和灵活性，这在本质上将是复杂的前端。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>播放器</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈Web--H5唤醒]]></title>
    <url>%2Fweb%2FLP20190802A%2F</url>
    <content type="text"><![CDATA[“There is no silver bullet” —Fred Brooks 前言在信息爆炸的时代，让客户主动去搜索发现，已经越来越难了。如何让精准用户去主动发现，成为APP运营的核心，也是APP推广的重点，特别是在移动互联网的时代，社交成为营销的核心，APP引流是一大亮点，这里引流有两种形式，引导已下载用户打开APP，引导未下载用户下载APP。从技术的层面来说，就需要一个合理可行的方案来解决如何从H5（网页）中唤醒APP，同时又能给予用户直观且优雅的体验。 浏览器与APP其实二者彼此根本就是风马牛不相及，浏览器也可以看作是一个应用程序，只不过APP中可以通过WebView控件来获得展示web页面的功能。不管在iOS还是Android上，在浏览器中运行的的网页（脚本）都无法直接获取本机APP相关信息。 一般来说，我们使用的智能设备上有许多我们的个人信息。比如：联系方式、银行卡/信用卡信息、支付宝/Paypal/各大商城的账户密码、照片甚至行程与位置信息等，如何让这些信息仅在设备所有者本人知情并允许的情况下被使用，是所有智能设备与操作系统所要在乎的核心安全问题。针对这个问题，iOS使用了沙盒机制目的就是让APP只能访问它声明可能访问的资源。 URL Scheme新技术的产生是为了解决问题，解决问题的同时可能也会产生新的问题，毕竟没有银弹。在保障信息安全方面沙盒是个很好的解决办法，但也阻碍了应用间合理的信息共享。URL Schema 应运而生。 什么是URL Scheme对比我们熟悉的网址URL，Schema其实就是一种特殊的URL。 [scheme://][host][path][?query][#fragment]https://www.baidu.com/s?wd=paopaolee 像定位一个网页一样，我们可以使用URL Scheme定位一个APP甚至APP里某个具体的功能。 scheme://[path][?query] 其中Scheme对应APP标识， path对应APP的某个功能，query即为功能所需参数。这里列举出一些常用APP URL Scheme 虽然URL Scheme类似于网页URL，但两者还是有很大区别的，其中： 网页都有自己的网址，而APP不一定有自己的URL Scheme, 一个 App 是否支持 URL Schemes取决于App开作者是否添加了 URL Schemes相关的代码。 网页与网址是一一对应的关系，但是由于苹果没有对URL Schemes做唯一性硬性要求，故并非每个URL Schemes都只对应一款应用。(这可能会导致严重的安全性问题) APP可以向宿主操作系统注册一个URL Scheme，该scheme用于从浏览器或其他应用中启动本应用，通过scheme协议来跳转到相应的APP界面，比如商品详情，活动详情，商家详情等等界面。也可以执行某些指定动作，如完成支付等。也可以在应用内部通过H5页面来直接跳转APP某个界面。 URL Scheme应用场景 APP根据服务器下发URL Scheme跳转相应的页面 网页或H5页面通过URL Scheme启动相应APP并且可以跳转具体页面 APP通过URL Scheme跳转到另外一个APP指定页面URL Scheme的不足之处 现如今诸如微信、微博等主流的APP，已经屏蔽掉了URL Scheme iOS中使用URL Scheme唤醒APP时，会出现弹窗提示，并且失败也会出现提示窗，用户体验不太友好。 使用URL Scheme唤醒APP时，无法得知是否唤醒成功。Android IntentURL Scheme在Android的Chrome浏览器中存在很大差异，在18及之前的版本中的，URL Scheme能够正常工作，但是从版本25以后，通过URL Scheme已经无法启动一个android app了。取而代之是android 提供了Intent方案。什么是IntentAndroid中提供了Intent机制来协助APP间的交互与通讯。当然，它不仅可用于应用程序之间，也可用于应用程序内部的 Activity / Service之间的交互。它可以更灵活地控制应用程序的启动方式，并且可以通过Intent Extras将额外信息传递到APP。进一步了解Intent基本语法基于Intent的URI基本格式如下：123456789intent: HOST/URI-path // Optional host #Intent; package=[string]; action=[string]; category=[string]; component=[string]; scheme=[string]; end; 当无法解析Intent或无法启动外部APP时，默认会跳转到系统默认的应用程序商店，当然你也可以通过下方的代码选择给Intent定义一个回调URL，这样失败时会将用户重定向到定义的回调URL。 1S.browser_fallback_url=[encoded_full_url] 示例为了启动Zxing二维码扫描APP，可以通过如下的方式： 1&lt;a href=&quot;intent://scan/#Intent;scheme=zxing;package=com.google.zxing.client.android;S.browser_fallback_url=http%3A%2F%2Fzxing.org;end&quot;&gt; Take a QR code &lt;/a&gt; 对应的Intent如下： 123456intent: //scan/ #Intent; package=com.google.zxing.client.android; scheme=zxing; end; 其中//scan/对应HOST/URL-path, com.google.zxing.client.android;对应package, zxing对应scheme，这些参数都是在APP开发配置在Manifest中的。 Universal Link在iOS9之前，对于从各种从浏览器、Safari中唤醒APP的需求，我们通常只能使用URL Scheme。但是正如我们上面所说，URL Scheme有它自身的不足。其中最主要的是它并没有强制唯一，这可能会带来安全问题。 什是Universal LinkUniversal Link是iOS9推出的一项功能，使你可以通过传统的HTTP链接来启动APP(如果iOS设备上已经安装了你的app，不管在微信里还是在哪里)， 或者打开网页(iOS设备上没有安装你的app)。该方案较url scheme有明显的改善。URL Scheme很难做到唯一，而universal link却是你自己控制的，而且Universal Link实现了web-app无缝衔接，没有弹窗提示，用户体验明显好于URL Scheme。进一步了解Universal Link默认地，Universal Link能直接打开已安装的APP，无需通过Safari。如果用户没有安装对应的APP时，不同于Schema，Universal Link也是一个合法的URL地址，可以在Safari中打开。 Universal Link 的特点 唯一性: 不像自定义的URL Scheme，Universal 不能够被其它APP声明，因为它是使用标准的HTPPS或HTTP协议来链接到你的网站 安全性: 当用户安装您的APP时，iOS会检查您上传到您的web服务器的文件，以确保您的网站允许您的APP在其上打开网址。并且只有您可以创建并上传此文件，因此您的网站与APP的关联是安全的 灵活性: 即使你没有安装对应的APP，Universal Link也能在Safari中打开内容。 简单行: 一个URL就能使用户在网站和APP间切换。 私密性: 其它APP无需知晓你的APP是否已经安装也能通信 ⚠️： 当用户在Safari中浏览您的网站并点击了与当前网页同域的Universal Link时，iOS会直接在Safari中打开该链接。如果是不同域的Universal Link，iOS才会尝试在您的APP中打开。 从加载过程分析Universal Link的不足一个硬性的不足在于，Universal Link只在iOS9才开始支持，除此之外我们说Universal 就是标准的HTTPS或HTTP链接，那么我们先来看一下一般的URL在WebView中的加载过程，如图所示从解析URL到页面加载完成的过程：那么Universal Link 加载过程又是如何的呢？相信大家可以看到，Universal Link功能是很容易被封锁掉的，只需要在APP中判断你的域名是否在其允许的。现如今很多主流的APP，它们各自维护着一份白名单，除非你在它的白名单内，否则都会屏蔽掉唤醒操作。尤其是微信，除非腾讯系的APP，其它APP都无法从微信内容中被唤醒，所以淘宝推出了我们熟悉的淘口令。应用宝APP Link腾讯应用宝对外开放了一个叫做APP Link 的申请，只要你申请了APP Link，就可以通过在打开应用宝的时候在应用宝地址后面添加上 &amp;android_schema={your_scheme} ，来打开指定的页面了。进一步了解应用宝APP Link唤醒APP的具体实现上面我们介绍了几种启动APP的解决方案，无论是 URL Scheme 还是 Intent 或者 Universal Link、APP Link，他们都算是URL ，只是URL Scheme 和 Intent 算是特殊的 URL。所以我们可以如同使用URL的方法来使用它们。 iframeiframe方案的唤醒原理是: 程序切换到后台时，计时器会被推迟(计时器不准的又一种情况)。如果app被唤醒那么网页必然就进入了后台，如果用户从app切回来，那么时间一般会超过2s;若app没有被唤起，那么网页不会进入后台，setTimeout基本准时触发，那么时间不会超过2s 123456789101112131415161718192021222324var last = Date.now(), doc = window.document, ifr = doc.createElement('iframe');//创建一个隐藏的iframeifr.src = nativeUrl;ifr.style.cssText = 'display:none;border:0;width:0;height:0;';doc.body.appendChild(ifr);setTimeout(function() &#123; doc.body.removeChild(ifr); //setTimeout回小于2000一般为唤起失败 if (Date.now() - last &lt; 2000) &#123; if (typeof onFail == 'function') &#123; onFail(); &#125; else &#123; //弹窗提示或下载处理等 &#125; &#125; else &#123; if (typeof onSuccess == 'function') &#123; onSuccess(); &#125; &#125;&#125;, 1000); 在只有 URL Scheme 的日子里，iframe 是使用最多的了。因为在未安装 app 的情况下，不会去跳转错误页面。但是iframe 在各个系统以及各个应用中的兼容问题还是挺多的，不能全部使用 URL Scheme。 a标签1&lt;a href="intent://scan/#Intent;scheme=zxing;package=com.google.zxing.client.android;end""&gt;扫一扫&lt;/a&gt; window.location1window.location.href = 'sinaweibo://qrcode'; ⚠️： URL Scheme在ios 9+上诸如 safari、UC、QQ浏览器中， iframe 均无法成功唤起APP，只能通过 window.location才能成功唤端。当然，如果APP支持Universal Link，ios 9+就用不到URL Scheme了。而 Universal Link 在使用过程中，我发现在 qq 中，无论是 iframe 导航 还是 a 标签打开又或者 window.location都无法成功唤端，一开始我以为是 qq 和微信一样禁止了 Universal Link 唤端的功能，其实不然，百般试验下，通过top.location唤端成功了。 总结在唤醒功能的实现上没有完美通用的解决方案，我们只能根据特定的业务，在代码层上确保能够覆盖最常用的场景。这里推荐你两个较为通用的解决方案call-lib和web-launch-app。 参考文章 H5唤起APP指南 H5唤起APP]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set、Map、WeakSet、WeakMap的区别]]></title>
    <url>%2Fweb%2FLP20190710A%2F</url>
    <content type="text"><![CDATA[“Good programmers use their brains, but good guidelines save us having to think out every case.”—Francis Glassborow 前言 大多数主流编程语言都有多种内置的数据集合。例如Python拥有列表（list）、元组（tuple）和字典（dictionary）,Java有列表（list）、集合（set)、队列（queue）。然而JavaScript直到ES6的发布之前，只拥有数组（array）和对象（object）这两个内建的数据集合。ES6的出现，引入了诸如Map、Set、WeakeMap、WeakMap等新的数据结构为这门语言注入了新的能量和活力。 HashMap，Dictionary等数据结构是各种编程语言存储键/值对的几种方式，这些数据结构针对快速检索进行了优化。当然ES6中的Map、Set、WeakeMap、WeakMap这些数据结构底层都是通过（hash tables）散列表实现的。 Map在ES5中,我们通常使用内置的Object（它们只是具有键和值的属性的任意集合）模拟Map。但是这样做会有三个缺陷。 JavaScript中Object的属性键是String或Symbol，这限制了它们作为不同数据类型的键/值对集合的能力。当然，您可以将其他数据类型强制/字符串化为字符串，但这会增加额外的工作量。 Object不是设计来作为一种数据集合，因此没有有效的方法来确定对象具有多少属性(虽然有Object.keys，但是它很慢）。循环遍历对象的属性时，还会获得其原型属性。您可以将iterable属性添加到所有对象，但不是所有对象都可以用作集合。您可以使用for … in循环和hasOwnProperty（）方法，但这只是一种解决方法。循环访问对象的属性时，不一定按照插入的顺序检索属性。 Object具有内置方法，如constructor，toString和valueOf。如果其中一个作为属性添加，则可能导致冲突。虽然您可以使用Object.create(null)来创建一个裸对象（它不从object.prototype继承），但是这只是一个变通方法。 MDN对Map定义: Map对象保存键值对并记住键的原始插入顺序。任何值（对象和原始值）都可以用作键或值.其中key值的对比是基于一种类似于===操作符的算法，不过NaN被认为与自身相等（尽管JS中NaN!==NaN，因此Map中可以使用NaN作为key;&nbsp;Map中的键值对是有序的,因此在迭代时的顺序与插入时一致。 我们可以轻松创建Map，添加/删除值，迭代访问键/值并有效确定其大小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// new Map([iterable])let recipeMap = new Map([ ['Cucumber', '500 gr'], ['Tomatoes', '350 gr'],]);// Sets the value for the key in the Map object. Returns the Map object.recipeMap = recipeMap.set('Sour cream', '50 gr');// Returns a boolean asserting whether a value has been associated to the key in the Map object or not.console.log(recipeMap.has('Cucumber')); // true// loop by keysfor(let fruit of recipeMap.keys()) &#123; console.log(fruit); // Cucumber // Tomatoes // Sour cream&#125;// loop by values [key, value]for(let amount of recipeMap.values()) &#123; console.log(amount); // 500 gr // 350 gr // 50 gr&#125;// loop by recoedsfor(let entry of recipeMap) &#123; // same like recipeMap.entries() console.log(entry); // ["Cucumber", "500 gr"] // ["Tomatoes", "350 gr"] // ["Sour cream", "50 gr"]&#125;// Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.console.log(recipeMap.delete('paopaolee')); // false // Removes all key/value pairs from the Map object.recipeMap.clear(); // Returns the number of key/value pairs in the Map object.console.log(recipeMap.size === 0); // True SetMDN对Map定义: Set简单来说就是不包含重复项的值的有序集合，它允许您存储任何类型，无论是原始值还是对象引用，不像数组那样使用索引，Set使用Key访问集合。Set已经存在于Java，Ruby，Python和许多其他语言中。 ES6的Set与其他语言之间的一个区别在于ES6中的Set是有序的。 123456789101112131415161718const planetsOrderFromSun = new Set();planetsOrderFromSun.add('Mercury');planetsOrderFromSun.add('Venus').add('Earth').add('Mars'); // Chainable Methodconsole.log(planetsOrderFromSun.has('Earth')); // TrueplanetsOrderFromSun.delete('Mars');console.log(planetsOrderFromSun.has('Mars')); // Falsefor (const x of planetsOrderFromSun) &#123; console.log(x); // Same order in as out - Mercury Venus Earth&#125;console.log(planetsOrderFromSun.size); // 3planetsOrderFromSun.add('Venus'); // Trying to add a duplicateconsole.log(planetsOrderFromSun.size); // Still 3, Did not add the duplicateplanetsOrderFromSun.clear();console.log(planetsOrderFromSun.size); // 0 弱集合，内存和垃圾回收JavaScript垃圾回收机制是一种内存管理形式，可以自动删除不再引用的对象并回收其资源。 JS中，当一个对象被引用的时候，往往意味着它正在被使用，或者在将来有可能会被使用。此时对象所占用的内存不会被垃圾回收机制回收掉。Map和Set所引用的对象会被保留，不允许进行垃圾回收。如果Map和Set引用着不再需要的大对象（例如已经从DOM中删除的DOM元素），这可能会消耗大量内存。 &nbsp; 为了解决这个问题，ES6还引入了两个名为WeakMap和WeakSet的新弱集合。这些ES6集合是“弱”的，因为它们允许从内存中清除不再需要的对象。 &nbsp;弱引用则可以理解为“引用了对象，但是不影响它的垃圾回收”，举个🌰: 1234567var obj = &#123;&#125;;var wm = new WeakMap();wm.set(obj, 1);wm.get(obj); // 1......obj = null;wm.get(obj); // 这句没有意义 在这个例子中，WeakMap实例wm（弱）引用了obj对象（空对象），接着下方代码释放了对空对象的引用（obj = null），此时和上例一样，空对象将被垃圾回收。也即wm中持有的空对象（弱）引用并不影响对对象本身的垃圾回收。这就是WeakMap中“弱引用”的含义。 WeakMapMDN对Map定义: WeakMap是一种弱引用key的键值对（key/value）集合，其键（key）必须是一个对象，值（value）可以为任意类型。正由于这样的弱引用，WeakMap的key是无法枚举的 (即无法列举所有的key)。如果key是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。所以无法使用for…in或者for…of等语句迭代。 WeakMap使用场景&nbsp;WeakMaps有几个流行的用例。它们可用于保持对象的私有数据私有化，它们还可用于跟踪DOM节点/对象。 场景一使用WeakMap简化了保持对象数据私有的过程。privateData可以引用Person对象，但不允许在没有特定Person实例的情况下访问，而且随Person实例对象的销毁而消失。 123456789101112var Person = (function() &#123; var privateData = new WeakMap(); function Person(name) &#123; privateData.set(this, &#123; name: name &#125;); &#125; Person.prototype.getName = function() &#123; return privateData.get(this).name; // 只能通过Person实例访问对应的name &#125;; return Person();&#125;()); 场景二使用WeakMap处理事件绑定,在React中如果用到事件监听处理，通常我们必须要在对应的生命周期中相应的进行事件绑定或解除，以防止内存泄漏。然而如果使用WeakMap，我可以不用担心这些问题。 123456789101112131415161718192021222324var listeners = new WeakMap();// 监听事件function on(object, event, fn)&#123; var thisListeners = listeners.get(object); if(!thisListeners) thisListeners = &#123;&#125;; if(!thisListeners[event]) thisListeners[event] = []; thisListeners[event].push(fn); listeners.set(object, thisListeners);&#125;// 触发事件function emit(object, event)&#123; var thisListeners = listeners.get(object); if(!thisListeners) thisListeners = &#123;&#125;; if(!thisListeners[event]) thisListeners[event] = []; thisListeners[event].forEach(function(fn)&#123; fn.call(object, event); &#125;);&#125;// 使用var obj = &#123;&#125;;on(obj, 'hello', function()&#123; console.log('hello');&#125;);emit(obj, 'hello'); 场景三使用WeakMap跟踪DOM节点编辑，删除和更改。例如，Google的Polymer项目在一段名为PositionWalker的代码中使用了WeakMap PositionWalker keeps track of a position within a DOM subtree, as a current node and an offset within that node. 12345678910111213141516171819202122_makeClone() &#123; this._containerClone = this.container.cloneNode(true); this._cloneToNodes = new WeakMap(); this._nodesToClones = new WeakMap(); ... let n = this.container; let c = this._containerClone; // find the currentNode's clone while (n !== null) &#123; if (n === this.currentNode) &#123; this._currentNodeClone = c; &#125; this._cloneToNodes.set(c, n); this._nodesToClones.set(n, c); n = iterator.nextNode(); c = cloneIterator.nextNode(); &#125;&#125; WeakSetMDN对Map定义: WeakSet是弱引用的Set，当不再需要它们引用的对象时，它们的元素可以被垃圾收集。 WeakSet不允许迭代。 123456789101112var ws = new WeakSet();var foo = &#123;&#125;;var bar = &#123;&#125;;ws.add(foo);ws.add(bar);ws.has(foo); // truews.has(bar); // truews.delete(foo); // removes foo from the setws.has(foo); // false, foo has been removed WeakSet使用场景WeakSet使用场景相当有限（至少目前为止）。大多数早期采用者都说WeakSet可用于标记对象而不会改变它们。ES6-Features.org有一个添加和删除WeakSet中元素的示例，以便跟踪对象是否已被标记: 12345678910111213141516171819202122232425262728293031323334353637let isMarked = new WeakSet()let attachedData = new WeakMap()export class Node&#123; constructor(id)&#123; this.id = id; &#125; mark()&#123; isMarked.add(this); &#125; unmark()&#123; isMarked.delete(this); &#125; marked()&#123; return isMarked.has(this); &#125; set data(data)&#123; attachedData.set(this, data); &#125; get data()&#123; return attachedData.get(this); &#125;&#125;let foo = new Node("foo")JSON.stringify(foo) === '&#123;"id":"foo"&#125;'foo.mark()foo.data = "bar"foo.data === "bar"JSON.stringify(foo) === '&#123;"id":"foo"&#125;'isMarked.has(foo) === trueattachedData.has(foo) === truefoo = null /* remove only reference to foo */attachedData.has(foo) === falseisMarked.has(foo) === false 参考文章 ES6 Collections: Using Map, Set, WeakMap, WeakSet ES2015 WeakMap的学习和使用 JavaScript (ES-2015) Set, Map, WeakSet and WeakMap V8: Optimizing hash tables: hiding the hash code]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JS</tag>
        <tag>Map</tag>
        <tag>Set</tag>
        <tag>WeakMap</tag>
        <tag>WeakSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶--Iterator and Generator]]></title>
    <url>%2Fweb%2FLP20180917A%2F</url>
    <content type="text"><![CDATA[“The best programmers are not marginally better than merely good ones. They are an order-of-magnitude better, measured by whatever standard: conceptual creativity, speed, ingenuity of design, or problem-solving ability.” —Randall E. Stross 前言大多数编程语言已经从使用for循环（需要初始化变量以便跟踪数据在集合中的位置）转而使用以编程方式返回集合中下一项的迭代器对象来迭代数据。 尽管迭代器使得处理数据集合更加容易,但是由于需要显式地维护其内部状态，因此它们的创建需要谨慎的编程。生成器函数提供了一个强大的选择：它们允许您通过编写一个执行不连续的函数来定义迭代算法。 循环的秘密如果你使用JavaScript(ES5)来编写过程序，那你很可能写类似一下子的代码： 1234var colors = ["red", "green", "blue"];for(var i = 0; i &lt; colors.length; i++)&#123; console.log(colord[i]);&#125; 这种用最原始for循环来迭代数组(或类数组对象)是最简单也是最直观的，需要使用变量来追踪colors数组的索引位置，变量的值会随着每次迭代而递增直到它大于数组的长度值。虽然上面的循环十分简单，但是当你嵌套循环并且需要跟踪多个变量时，循环会变得复杂。额外的复杂性可能导致错误，并且for循环的样板性质会导致更多错误，因为类似的代码写在多个地方。而迭代器旨在解决这些问题。 类数组对象的玄机众所周知，在JavaScript中遍历数组中的每一个元素是一件很简单的事情，我们可以通过最原始的for、while循环，或ES6为我们提供的for-of之类的众多方法来实现；那么为什么这些方法就可以遍历数组或类数组对象（String、Map、Set、arguments）呢？而为什么这些方法不能遍历Object呢？古人有云：要想战胜它，就先成为它；那么我们就先来来看看类数组对象究竟是什么货色。我分别打印了Array、Map、Set、还有String等类数组对象的信息，发现它们有一个共同的特征：其原型对象上都实现了[Symbol(Symbol.iterator)]方法。 可迭代协议在实际编程工作中，我们除了会使用数组这样的数据结构之外，还会大量使用自定义数据结构，那么我们如何去遍历或者说使这些自定义数据结构能够被循环迭代呢？上一节的[Symbol(Symbol.iterator)]方法会不会对此有用呢？可迭代协议允许JavaScript对象定义或自定义其迭代行为，例如在for..of构造中循环的值；为了实现可迭代性，对象(或其原型上)必须实现Symbol.iterator方法，该方法返回一个叫做迭代器的对象。 实现123456789101112131415161718192021222324252627const iterable = &#123; [Symbol.iterator]()&#123; let step = 0; const iterator = &#123; next()&#123; if(step &lt; 3)&#123; step++; return (&#123; value: step, done: false, &#125;); &#125; return &#123; value: step, done: true, &#125; &#125; &#125;; return iterator; &#125;&#125;;const iterator = iterable[Symbol.iterator]();iterator.next() // &#123;value: 1, done: false&#125;iterator.next() // &#123;value: 2, done: false&#125;iterator.next() // &#123;value: 3, done: false&#125;iterator.next() // &#123;value: 3, done: true&#125; 应用JavaScript中一些内置数据类型是具有默认迭代行为的内置可迭代类型，例如String、Array、Mapy及Set，因为它们的原型上实现了[Symbol.iterator]方法，其实就是实现了可迭代协议。当然还有很多地方使用了可迭代性，有的可能不太明显，比如： for-of循环 数组结构 ES6扩展运算符 Map和Set的构造函数要求是可迭代对象Iterator（迭代器）定义MDN定义： 迭代器仅仅是具有为迭代设计的特定接口的对象。所有的迭代器对象都有一个“next()”方法,这个方法返回一个含有value和done两个字段的对象，其中value字段的值就是当前从数据集合中迭代出的值；而done字段的是一个布尔值，用来表示迭代是否已经完成。迭代器一旦被创建， 我们就能通过重复调用“next()”方法来迭代它，在产生终止值后继续调用next()方法应该始终返回{done: true} 案例123456789101112131415161718192021222324252627282930function makeRangeIterator&lt;T&gt;(dataCollection: Array&lt;T&gt;, start=0, step=1,end=Infinity,)&#123; const len = dataCollection.length; let nextIndex = start; let iterationValue: T; return &#123; next: function (param?: any): &#123;value: T, done: boolean&#125; &#123; if(nextIndex &lt; end &amp;&amp; nextIndex &lt; len)&#123; iterationValue = dataCollection[nextIndex]; nextIndex += step; return &#123; value: iterationValue, done: false, &#125; &#125; return &#123; value: iterationValue, done: true, &#125; &#125; &#125;&#125;var iterator = makeRangeIterator(["s",3,&#123;name: 'paopaolee'&#125;],0,1,3);console.log(JSON.stringify(iterator.next())); // &#123;"value":"s","done":false&#125;console.log(JSON.stringify(iterator.next()));// &#123;"value":3,"done":false&#125;console.log(JSON.stringify(iterator.next()));// &#123;"value":&#123;"name":"paopaolee"&#125;,"done":false&#125;console.log(JSON.stringify(iterator.next()));// &#123;"value":&#123;"name":"paopaolee"&#125;,"done":false&#125; 下面这张图可以帮组我们建立可迭代性、迭代器、next之间的关系： Generator（生成器）虽然自定义迭代器是一个十分有用的工具，但是从上面代码可以看出由于需要去显示维护其内部状态，所以创建迭代器需要谨慎的编程。生成器是一个强有力的替代工具，它使得我们可以更简单的创建迭代器对象。 定义MDN定义: 生成器是一个返回迭代器的函数，它允许通过编写一个非连续执行的函数来定义迭代算法。它的的语法为“function* FuncName(){ }”。首次调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。通过调用生成器的“next”方法消耗值时，Generator函数将执行，直到遇到yield关键字。 简而言之，JavaScript中生成器是一个返回值为迭代器的函数，与普通函数不同的是，生成器函数在执行过程中可以中断并且能从中断的地方继续执行。下面的这张图对比了普通函数与生成器函数执行过程： 举例说明123456789101112131415function* generatorFunction()&#123; // line 1 console.log('This will be executed first.') yield 'Hello,'; // line 2 console.log('Iwill be printed after the pause.'); yield 'World!'; &#125;const generatorObject = generatorFunction(); // line 3console.log(generatorObject.next().value); // line 4// This will be executed first.// Hello, console.log(generatorObject.next().value); // line 5// I will be printed after the pause// World!console.log(generatorObject.next().value); // line 6// undefined 上面代码中，我们使用了function* 的语法创建了一个生成器函数（line 1），在函数内部我们使用了另一个关键字yield（line 2），它只能在生成器中使用。生成器函数在执行过程中一旦运行到yield关键字时，会立即“返回”定义在它后面的值并中断函数的执行，注意此处的返回跟普通函数的return不同，在生成器上下文中，我们叫（yield）产出某值。 12345function * generatorFunc() &#123; yield 'a'; return 'b'; // Generator ends here. yield 'a'; // Will never be executed. &#125; 在（line 3）中我们通过创建了generatorObject对象，这看起来貌似生成器函数“generatorFunction”内部的语句应该已经执行，但是神奇的是第一句console.log为啥并没有打印输出呢？原来是，当生成器函数执行时总是简单的返回一个迭代器对象，然后通过调用这个迭代器对象的next方法，生成器函数内部语句才会开始执行； 所以（line 3 中）generatorObject就是一个迭代器对象，然后我们通过调用它的next方法（line 4）,这时生成器“generatorFunction”才开始真正执行，打印出”This will be executed first.“；接着执行下一行代码（line 2），这时遇到了yield关键值，将其后定义的‘Hello’字符串作为值，产出“{value: ‘Hello’, done: false}”对象,同时会被暂时中断挂起，直到迭代器再次调用next方法； 在line 5中，我们再次调用了next，这时生成器函数被唤醒并从上一次挂起的地方继续开始执行，所以打印出”I will be printed after the pause“，接着又遇到了yield关键字，产出”{value: ‘World！’, done: false}”后再次挂起； 在line 5中，我们又再一次调用了next，这次生成器函数被唤醒后发现没有语句可以执行了，记住如果函数没有return语句，默认返回undefined,因此生成器函数会产出”{value: undefined, done: true}”,属性值done被设置为true，这就意味着生成器函数执行结束了。 应用场景一 . 实现可迭代前面有提到要实现可迭代性，对象(或其原型上)必须实现[Symbol.iterator]方法来返回一个我们自己编写的迭代器，这使得实现过于复杂，而生成器函数可以使我们更简单的创建迭代器对象。接下来我们分别使用自定义迭代器和生成器来实现可迭代行对象。自定义迭代器： 12345678910111213141516171819const iterableObj = &#123; [Symbol.iterator]: () =&gt; &#123; let step = 0; return &#123; next: () =&gt; &#123; step++; if (step === 1) &#123; return &#123; value: 'This', done: false&#125;; &#125; else if (step === 2) &#123; return &#123; value: 'is', done: false&#125;; &#125; else if (step === 3) &#123; return &#123; value: 'iterable.', done: false&#125;; &#125; return &#123; value: '', done: true &#125;; &#125; &#125;; &#125;&#125;;[...iterableObj] // ["This", "is", "iterable."] 生成器 1234567function * generatorFunc() &#123; yield 'This'; yield 'is'; yield 'iterable.'&#125;const iterableObj = generatorFunc();[...iterableObj] // ["This", "is", "iterable."] 你可以比较两个版本，它可以说明生成器带来的诸多好处： 我们不需要关心Symbol.iterator 我们不再必须实现next方法 我们不再关心必须像在next方法中返回{value: ‘This’, done: false}这样的对象结构 我们不用去维护迭代器内部的状态 二. 异步任务处理生成器最让人兴奋的地方与异步编程相关。 JavaScript中的异步编程是一把双刃剑：简单的异步任务很容易完成，而复杂的异步任务成为代码组织的一个苦差事。然而生成器允许您在执行过程中有效地暂停代码，因此它们开辟了许多与异步处理相关的可能性。 解决异步任务的传统方法是回调函数，这种方法能够很好地解决简单的业务，但是一旦业务过于复杂，这种方法往往使得嵌套多层代码造成回调地狱。得益于yield关键字可以中断挂起函数直到next方法的调用，我们可以不需要管理回调函数就能实现异步编程。 高级迭代器功能传递参数到迭代器在上述迭代器的案例代码中可以发现，迭代器的next方法其实可以接受参数。在生成器函数中，将参数传递给next（）方法时，该参数将成为生成器内yield语句的值。此功能对于更高级的功能（如异步编程）非常重要。这是一个基本的例子： 123456789101112131415function * createIterator()&#123; let first = yield 1; // line 1 let seccond = yield first + 2; // line 2 yield second + 3; // line 3&#125;const iterator = createIterator();console.log(iterator.next()); // line 4// "&#123; value: 1, done: false &#125;"console.log(iterator.next(4)); // line 5// "&#123; value: 6, done: false &#125;"console.log(iterator.next(5)); // line 6 // "&#123; value: 8, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 上面代码中，我们在第一次调用next方法时（line 4），生成器函数内部开始执行（line 1），执行过程中由于赋值语句是从右往左执行的，一开始就遇到yield关键值，产出”{value: 1, done: flase}”,然后中止挂起函数等待下一次next方法调用，注意此时变量first还没有被赋值；当我们再次调用（line 5）next方法（值得注意的是，此次调用next方法时还传入了参数4），函数从上一次中止的地方（line 1 表达式右边）被唤醒继续执行，此时参数4会被当作yield语句的执行结果赋值给变量first，接着执行下一行（line 2）直到遇到yield，产出”{value: 6(4+2), done: false}”然后中止；继续我们第三次调用next（line 6），这次yield接受参数5赋给变量second，产出”{value: 8(5+3), done: false}”后再次中断挂起；最后一次调用next，函数被唤醒后发现没有语句可以执行，且函数没有return语句（即默认返回undefined），所以默认返回”{value: undefined, done: true}”; 注意，首次调用next方法传入的参数是无效的，会被函数完全忽略掉。即上面(line 4)代码中的next函数中传入任何参数都是无效的。 在生成器中抛出和捕获错误我们通过迭代器的next方法不仅能传递数据，而且还能传递Error信息。迭代器可以选择实现一个throw（）方法，该方法指示迭代器在恢复时抛出错误。 function * createIterator(){ let first = yield 1; // line 1 let seccond； try{ second = yield first + 2; }catch(error){ second = 6; } yield second + 3; // line 3 } let iterator = createIterator(); console.log(iterator.next()); // "{ value: 1, done: false }" console.log(iterator.next(4)); // "{ value: 6, done: false }" console.log(iterator.throw(new Error("Boom"))); // "{ value: 9, done: false }" console.log(iterator.next()); // "{ value: undefined, done: true 在生成器函数中使用return语句我们说过生成器就是一个函数，我们可以像普通函数那样在生成器中使用return语句，它默认会将返回值中的done属性设置为true，也就意味着你可以通过使用return语句提前退出函数或为定义最后一次调用next方法的产出值。 function * createIterator(){ let first = yield 1; // line 1 let seccond = yield first + 2; // line 2 return 1000; yield second + 3; // line 3 } 上面代码中，第三次调用next方法后，产出值为”{value: 1000, done: true}”,并且函数会退出。 特殊地，ES6中的扩展运算符和for-of操作符会忽略掉任何return语句定义的值。因为它们首先检查对象中的done属性是否为true，一旦done为true便不会在读取value属性。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈Web--JWT]]></title>
    <url>%2Fweb%2FLP20190709A%2F</url>
    <content type="text"><![CDATA[“The most amazing achievement of the computer software industry is its continuing cancellation of the steady and staggering gains made by the computer hardware industry.” —Henry Petroski 前言随着技术的发展，分布式web应用的普及，通过session管理用户登录状态成本越来越高，因此慢慢发展成为token的方式做登录身份校验，然后通过token去取redis中的缓存的用户信息，随着之后jwt的出现，校验方式更加简单便捷化，无需通过redis缓存，而是所有数据都保存在客户端，每次请求都发回服务器，随后服务器直接根据token取出保存的用户信息，以及对token可用性校验，单点登录更为简单。 这篇文章中主要讲解了关于JSON Web Tokens（JWT）的基础概念，以及解释JWT为什么会被广泛应用。JWT是确保应用程序信任和安全的重要部分，它允许以诸如用户数据之类的安全的方式声明表示。 为了JWT的工作原理，我们先来看一看关于它的抽象定义： JSON Web Token（JWT）是一种JSON对象，在RFC 7519中定义为表示双方之间的一组信息的安全方式；它由头部、有效负载和签名三部分组成。 我们完全可以把JWT简单地看成仅仅是符合以下格式的字符串 header.payload.signature Notes: 合法的JSON必须是使用双引号的字符串 为了理解JWT是如何被使用的，我们将使用User（用户）、Application Server（应用服务器）、Authentication Server（授权服务器）3个简单的实体加以解释说明。其中Authentication Server将提供JWT给用户，用户拿到JWT后就可以和应用（app/website）安全地通信。 上图中，User携带用户名/密码等可证明身份的内容去授权服务器获取JWT信息，每次服务都携带该Token内容与应用服务器进行交互，由应用服务器来验证Token是否是授权系统发放的有效Token，来验证当前业务是否请求是否合法。 接下来我们深入理解JWT是如何构造以及如何验证的。 第一步 创建头部（header）JWT的头部包含了JWT自身的签名算法信息，它是一个具有如下格式的JSON对象： 1234&#123; "typ": "JWT", "alg": "HS256"&#125; 这个JSON中, typ属性表示令牌的类型，JWT令牌统一写为JWT。alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256） 第二部 创建有效载荷（payload）JWT的有效载荷即是JWT的主体内容部分,包含了需要传递的数据（这些数据也被称为JWT的声明）。在我们的🌰中，JWT中存储了用户ID信息。 123&#123; "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"&#125; 上面的🌰中，我们的JWT仅仅存储了一个信息。然而JWT 规定了7个官方字段，供选用 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 当然除了官方字段，你还可以在这个部分定义私有字段，诸如： 12345&#123; "sub": "1234567890", "name": "John Doe", "admin": true&#125; 值得注意的是有效载荷的存储数据的大小会影响整个JWT的大小，一般来说对JWT的大小没有限制但是过大的JWT可能会影响性能或造成潜在的问题。 第三步 创建签名（signature）签名是为了防止数据被篡改。 JWT的签名使用以下伪代码实现： 1234// signature algorithmdata = base64urlEncode( header ) + “.” + base64urlEncode( payload )hashedData = hash( data, secret )signature = base64urlEncode( hashedData ) 该算法所做的使用base64urlEncode对在第一步创建的头部和第二部中的有效负载分别进行编码并用”.”号拼接成字符串。随后使用JWT头中指定的散列算法对字符串使用密钥进行散列。最后再使用base64urlEncode对生成的散列数据进行编码以产生JWT签名。（密钥只有服务器才知道，不能泄露给用户） 这篇文章中，使用base64urlEncode对header和payload进行编码后得到如下结果： 1234567891011// headerbase64urlEncode(&#123; "typ": "JWT", "alg": "HS256"&#125;)eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9// payload// base64urlEncode(&#123; "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"&#125;)eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ 然后将结果代入上面的伪代码会得到如下签名： 12// signature-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM 第四步 生成JWT现在我们已经创建完成了JWT的header、payload、signature3个部分，那么再按照 header.payload.signature 的格式将3个部分组合起来就是所谓的JWT了。如下就是我们🌰中的JWT 12// JWTeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM 在JWT官方网站，你可以尝试创建自己的JWT。 回到我们的案例，这个Authentication Server 已经创建了一个JWT，并且发给了用户。 JWT是怎么保护数据的注意，这里经常会有一个误区，JWT本身和安全没关系，它就仅仅只是一个字符串，使用它来做安全远不如类似于RSA2这样的非对称加密的形式来的实在，由于客户端的程序对用户几乎完全透明，验签的过程对于他们来讲也是透明的，所以安全性肯定不会靠这个来实现，如果实在怕JWT的被盗取，可以考虑在Payload部分加入一些客户端独有的非敏感信息，用于在服务端来进行核验，比如使用MAC-Message Authentication Code、或者公钥之类的等等; 或者干脆就把生效时间设置的短一些，也可以减少暴露的风险。 JWT的数据被编码和被签名，但是没有被加密。编码的目的是转化数据结构，签名是为了数据的接收者验证数据的权威性。所以编码和签名并不会保护数据的安全性。而加密的主要目的才是为了保护数据安全防止未授权访问。对于详细描述编码与加密的区别，可以参考这篇文章。 Since JWT are signed and encoded only, and since JWT are not encrypted, JWT do not guarantee any security for sensitive data. 由于JWT仅仅被编码和签名而没有被加密过的，所以它无法保证任何敏感信息的安全性。 第五步 验证JWT第四步中我们已经知道JWT的签名生成需要用密钥（secret），这个密钥只有授权服务器知道。应与服务器开启认证处理时，需要从授权服务器获取此密钥。此后当用户携带JWT访问应用服务器时，应用服务器拿到JWT后可以通过类似第三步的方法生成一个签名，然后与用户携带的JWT的签名进行对比从而验证用户JWT是否有效。 结束语本文中描述的JWT认证设置使用对称密钥算法（HS256）。您也可以使用非对称算法（例如RS256），即授权服务器具有密钥，并且应用程序服务器具有公钥。了解使用对称和非对称算法之间差异的详细分类。 还应该注意，JWT应该通过HTTPS连接（而不是HTTP）发送。HTTPS有助于防止未经授权的用户窃取所发送的JWT，从而无法拦截服务器和用户之间的通信。 同时，JWT应该设置有效期，并且有效期不要太长。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶--bind原理及实现]]></title>
    <url>%2Fweb%2FLP20190705A%2F</url>
    <content type="text"><![CDATA[“Programmers are in a race with the Universe to create bigger and better idiot-proof programs, while the Universe is trying to create bigger and better idiots. So far the Universe is winning.” —Rich Cook 官方描述首先我们先来看看MDN上对于bind函数的定义，主要有三个特点: bind函数会创建一个新函数（称为绑定函数），新函数与原函数具有相同的函数体（在 ECMAScript 5 规范中内置的call属性） 当生成的新函数被调用执行时，其this值始终指向bind函数的第一个参数且无法改变 bin函数可以接受预设的参数，该参数最终提供给原函数 新函数也能使用new操作符创建对象,这种行为就像把原函数当成构造器。提供的 this值被忽略，同时调用时的参数被提供给模拟函数 用例说明众所周知，JS中函数(ES6箭头函数除外)的this指向是在函数执行时动态绑定的，函数定义和实际运行时的所处的环境不一样，往往导致未知的bug。 尤其是在React组件中，经常会由于this指向问题导致无法调用到函数，所以通常我们会在constructor函数中使用bind函数来绑定this(当然一般我们都会使用箭头函数来避免此类情况)。 123456789101112131415var name = "paopaolee"function test()&#123; console.log(this.name)&#125;var obj = &#123; name: "lepaopao", print: test,&#125;test(); // paopaoleeobj.print(); // lepaopaovar obj1 = &#123; name: 'xxxxxx', print: test.bind(this) // 返回了一个新函数并且this指向window&#125;obj1.print(); // paopaolee 动手实现第一版目标：实现描述中的特征1、2、3 分析：返回的结果是一个函数；新函数调用时this指向第一个参数， 可以通过call/apply函数解决，call/apply函数的区别在于参数传递，前者需逐一列出，后者可以传递数组；bind函数可接受预设参数最终提供原函数，由于参数不确定，所以选用apply实现。 实现： 12345678Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var self = this; //普通调用时， this指向bind调用者 var args = slice(arguments, 1); return function () &#123; self.apply(Othat, args); &#125;&#125; 第二版问题：第一版中初步实现了前三个特征，当然还有诸多问题，例如如果新函数执行时需要有返回值、第一版中实现了绑定时传参，那新函数调用时传参数呢？以及bind函数调用不正确等等。 优化： 1234567891011121314Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); return function () &#123; // 解决: 新函数执行时return返回值 return self.apply(Othat, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125;&#125; 第三版目标： 解决bind函数的第三个特征: 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说bind执行返回的新函数作为构造函数执行时，bind时指定的对象(参数Othat)会失效，但是传入的参数依然有效。 举个🌰： 123456789101112131415161718var vaule = 2var obj = &#123; value: 1&#125;function female(name, age)&#123; this.favorite = 'shopping'; console.log(this.value); console.log(name, age);&#125;female.prototype.husband = 'leepaopao';var boundFunc = female.bind(obj, 'paopaolee');var p = new bindedFunc(23);// undefined// paopaolee 23consple.log(p.habit); // shoppingconsple.log(p.husband); // leepaopao 尽管在window以及obj中都声明了value值，但最终(this.value)依然返回了undefined，说明此时this即不指向window也不指向obj，bind时绑定的this（obj）失效了。所以此时this真正指向的是female的实例。 分析： 要判断新函数调用时是否为new构造函数调用，可以通过this是否为新函数的实例,所以我们把返回的匿名函数换成具名函数，以便判断。 实现 1234567891011121314151617Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; return boundFunc;&#125; 第四版问题： 第三版中，我们解决了bind函数的第4个特征，但是使用new操作符创建对象时，this指向的是boundFunc的实例，无法继承原函数的原型中的属性，原型链遭到破坏。 目标：重塑原型链 实现： 123456789101112131415161718Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; boundFunc.prototype = this.portotype; return boundFunc;&#125; 上述代码，重塑原型链的做法是直接将boundFunc.prototype = this.prototype，相当于直接用原函数的prototype覆盖掉了boundFunc函数原来的prototype，这样如果我们更改boundFunc.prototype中的属性是也会影响原函数的prototype上的属性。 最终版12345678910111213141516171819202122232425Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; // 重塑原型链: 方法一 boundFunc.prototype = Object.create(this.portotype); // 重塑原型链: 方法二 /**** function fNOP ()&#123;&#125; fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); ****/ return boundFunc;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的装箱拆箱机制?:自动类型转换]]></title>
    <url>%2Fweb%2FLP20170809A%2F</url>
    <content type="text"><![CDATA[“Programming is like sex: one mistake and you’re providing support for a lifetime.” —Michael Sinz 介绍最近在通过看红宝书《javascript 高级教程》学习js, 由于自己有过编写Java程序的基础，所以在学习JS过程中潜意识地会与Java语言中的相关特性进行对比。在学习javascript基本的数据类型时，书中大致有这么一段内容： 123&gt; var str1 = "some text";&gt; var str2 = str1.substring(3);&gt; 字符串当然是基本类型基本类型值，然而这里却调用它substring方法，从逻辑上将它不应该有方法，其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理：(1) 创建String类型的一个实例；(2) 在实例上调用指定的方法；(3) 销毁这个实例经过这种处理，基本的字符串类型就变得跟对象一样了。而且上面的三个步骤也适用于Boolean和Number类型对应的布尔值和数字值。 看到这里，我想说这不就是Java中的自动装箱吗？ 什么叫自动装箱Java中，自动装箱(autoboxing)是指将原始值转换为相应包装器类的对象称为自动装箱。例如，将int转换为Integer类。以下情况中Java编译器会应用自动装箱： 将原始值作为参数传递给一个期望接收该原始值对应包装类的对象的方法； 将原始值赋值给一个类型为其对应的包装类对象的变量；当然自动拆箱就是装箱的逆过程，主要发生在： 将包装类对象作为参数传递给一个期望接收对应原始值的方法时； 将包装类对象赋值给一个类型为其对应原始值的变量；JavaScript的自动拆装箱机制其实JavaScript语言规范中，并没有提及自动拆装箱的概念，不过MDN中倒是有提到过类似概念： function.apply(thisArg, [argArry])thisArg: The value of this provided for the call to func. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed. This argument is not optional 与Java这种完全面向对象的静态语言截然不同，JavaScript是一门动态的语言，它甚至都没有类概念（即使ES6带来class,但是它也只不过语法糖），这使得它具有很大的灵活性，当然也带来了很多让人很难理解掌握的特性，比如==和===；所以对于Java中的自动拆装箱机制，在JS中其实可以理解为大家熟知的类型转换中的一种特殊情况。 JavaScript中的类型转换 类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时(runtime)。然而在 JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”(implicit coercion)和“显式强制类型转换”(explicit coercion)来区分。—— 引用自《你不知道的JS 上》 JavaScript是一种动态类型语言，对变量不会像静态语言那样做类型检查，可以随时赋予任意值，但是JS中各种运算符或表达式对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。例如最常见的，if语句需要一个布尔值，因此在括号中定义的任何内容都将转换为布尔值，while也是如此。 Javascript类型转换中有很多坑，就连Douglas Crockford在《Javascript: The Good Parts》一书中也极力 ‘吐槽’ 。 类型转换也分为显示类型转换和隐式类型转换， 隐式类型转换 当编译器在没有程序员干预的情况下自动执行类型转换，称为隐式类型转换。 上述的if语句中默认将值转换成布尔类型就属于隐式类型转换，10 + &#39;10&#39; == 20 也属于隐式类型转换;JS中的隐式类型转换其实理解为Java中的自动拆装箱。我们再来看上文介绍中的例子： 123&gt; var str1 = "some text";&gt; var str2 = str1.substring(3);&gt; 这里我们可以看出，str1在调用subString方法时，JS引擎自动将String类型str1变量通过new String()的方式隐式转换成了字符串对象，所以此时他才能访问subString属性方法，这个过程就对应着自动装箱；那么对应的，在执行完subString方法后，我们继续访问str1变量，那它的值依然会是”some text”，这又是问什么呢？按理说自动装箱后str1不应该是一个字符串对象吗？原来在执行完方法后，JS解释器又将str1变量通过str1.toString()(这里也可以通过str1.valueOf())隐式转换成了String类型，这个过程即为自动拆箱。 JS中的“自动装箱”机制其实就是将原始值类型隐式转换成引用类型的过程,这种情况主要发生在两种情况下： 在非严格模式下，传递一个原始值类型作为function.call/apply的this参数时 原始值类型访问属性时，例如： &quot;paopao lee&quot;.split(&#39; &#39;) 在第一种情况中，非严格模式下，当一个函数执行时，如果this值不是一个对象，那么它将其自动转换为对象，进一步了解 The following steps are performed when control enters the 》》 &gt; execution context for function code contained in function object F, a caller provided thisArg, and a caller provided argumentsList: if the function code is strict code, set the ThisBinding to thisArg. else if thisArg is null or undefined, set the ThisBinding to the global object. else if Type(thisArg) is not Object, set the ThisBinding to ToObject(thisArg).… 从上面可以看到，第3步中，原始值类型会被使用ToObject(thisArg)转换为对象。 第二种情况中，当你通过[]或.访问属性时会发生类似的事情。这里引用的部分解释了JS如何计算表达式foo[bar]。 The production MemberExpression: MemberExpression[Expression] is evaluated as follows: Let baseReference be the result of evaluating MemberExpression. Let baseValue be GetValue(baseReference).… Return a value of type Reference whose base value is &gt; baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 最重要的最后一步，无论MemberExpression计算什么，它都转换为Reference类型的值。这是一种仅在规范中使用的数据类型，并且包含关于如何从引用检索实际值的附加信息(不要与实际JavaScript代码中的对象引用混淆!)为了从Reference中获得“真实的”值或结果，会调用内部函数GetValue(V)(就像上面的步骤2): The following [[Get]] internal method is used by GetValue when V is a property reference with a primitive base value. It is called using base as its this value and with property P as its argument. The following steps are taken: Let O be ToObject(base).… 举个🌰： 1var foo = "BAR`.toLowerCase(); 这是一个赋值表达式，其计算方法如下： The production AssignmentExpression : LeftHandSideExpression = AssignmentExpression is evaluated as follows: Let lref be the result of evaluating LeftHandSideExpression. Let rref be the result of evaluating AssignmentExpression. Let rval be GetValue(rref).… 第1步: 左边求值，也就是标识符’foo’。标识符的解析方式并不重要第2步: 对右边求值，即&quot;BAR&quot;.toLowerCase(), 该计算的内部结果将是一个Reference并存储在rref中，类似于: 12345REFERENCE = &#123; base: "BAR", propertyNameString: "toLowerCase", strict: false&#125; 第3步: GetValue(rref)被调用,由于rref的引用值(REFERENCE)的base属性值是字符串”BAR”，是原始类，所以会调用ToObject将它暂时转换为String对象，此外，REFERENCE实际上代表了一个属性访问，因此GetValue(rref)最终会调用String对象上的方法toLowerCase并返回方法的结果。 显式类型转换 程序员强制执行的类型转换称为显式类型转换。基本上，程序员强制表达式为特定类型。 Explict类型转换也称为类型转换。 显示转换其实很好理解 12345678910// 字符串转换var a = 42;var b = String(a);// 数字转换var c = '3.14';var d = Number(c);// 布尔值转换var e = [];var f = Boolean(e)var f = !![]; 参考链接 Does javascript autobox? Type conversion - MDN]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
