<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Set、Map、WeakSet、WeakMap的区别]]></title>
    <url>%2Fweb%2FLP20190710A%2F</url>
    <content type="text"><![CDATA[“Good programmers use their brains, but good guidelines save us having to think out every case.”—Francis Glassborow 前言 大多数主流编程语言都有多种内置的数据集合。例如Python拥有列表（list）、元组（tuple）和字典（dictionary）,Java有列表（list）、集合（set)、队列（queue）。然而JavaScript直到ES6的发布之前，只拥有数组（array）和对象（object）这两个内建的数据集合。ES6的出现，引入了诸如Map、Set、WeakeMap、WeakMap等新的数据结构为这门语言注入了新的能量和活力。 HashMap，Dictionary等数据结构是各种编程语言存储键/值对的几种方式，这些数据结构针对快速检索进行了优化。当然ES6中的Map、Set、WeakeMap、WeakMap这些数据结构底层都是通过（hash tables）散列表实现的。 Map在ES5中,我们通常使用内置的Object（它们只是具有键和值的属性的任意集合）模拟Map。但是这样做会有三个缺陷。 JavaScript中Object的属性键是String或Symbol，这限制了它们作为不同数据类型的键/值对集合的能力。当然，您可以将其他数据类型强制/字符串化为字符串，但这会增加额外的工作量。 Object不是设计来作为一种数据集合，因此没有有效的方法来确定对象具有多少属性(虽然有Object.keys，但是它很慢）。循环遍历对象的属性时，还会获得其原型属性。您可以将iterable属性添加到所有对象，但不是所有对象都可以用作集合。您可以使用for … in循环和hasOwnProperty（）方法，但这只是一种解决方法。循环访问对象的属性时，不一定按照插入的顺序检索属性。 Object具有内置方法，如constructor，toString和valueOf。如果其中一个作为属性添加，则可能导致冲突。虽然您可以使用Object.create(null)来创建一个裸对象（它不从object.prototype继承），但是这只是一个变通方法。 MDN对Map定义: Map对象保存键值对并记住键的原始插入顺序。任何值（对象和原始值）都可以用作键或值.其中key值的对比是基于一种类似于===操作符的算法，不过NaN被认为与自身相等（尽管JS中NaN!==NaN，因此Map中可以使用NaN作为key;&nbsp;Map中的键值对是有序的,因此在迭代时的顺序与插入时一致。 我们可以轻松创建Map，添加/删除值，迭代访问键/值并有效确定其大小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// new Map([iterable])let recipeMap = new Map([ ['Cucumber', '500 gr'], ['Tomatoes', '350 gr'],]);// Sets the value for the key in the Map object. Returns the Map object.recipeMap = recipeMap.set('Sour cream', '50 gr');// Returns a boolean asserting whether a value has been associated to the key in the Map object or not.console.log(recipeMap.has('Cucumber')); // true// loop by keysfor(let fruit of recipeMap.keys()) &#123; console.log(fruit); // Cucumber // Tomatoes // Sour cream&#125;// loop by values [key, value]for(let amount of recipeMap.values()) &#123; console.log(amount); // 500 gr // 350 gr // 50 gr&#125;// loop by recoedsfor(let entry of recipeMap) &#123; // same like recipeMap.entries() console.log(entry); // ["Cucumber", "500 gr"] // ["Tomatoes", "350 gr"] // ["Sour cream", "50 gr"]&#125;// Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.console.log(recipeMap.delete('paopaolee')); // false // Removes all key/value pairs from the Map object.recipeMap.clear(); // Returns the number of key/value pairs in the Map object.console.log(recipeMap.size === 0); // True SetMDN对Map定义: Set简单来说就是不包含重复项的值的有序集合，它允许您存储任何类型，无论是原始值还是对象引用，不像数组那样使用索引，Set使用Key访问集合。Set已经存在于Java，Ruby，Python和许多其他语言中。 ES6的Set与其他语言之间的一个区别在于ES6中的Set是有序的。 123456789101112131415161718const planetsOrderFromSun = new Set();planetsOrderFromSun.add('Mercury');planetsOrderFromSun.add('Venus').add('Earth').add('Mars'); // Chainable Methodconsole.log(planetsOrderFromSun.has('Earth')); // TrueplanetsOrderFromSun.delete('Mars');console.log(planetsOrderFromSun.has('Mars')); // Falsefor (const x of planetsOrderFromSun) &#123; console.log(x); // Same order in as out - Mercury Venus Earth&#125;console.log(planetsOrderFromSun.size); // 3planetsOrderFromSun.add('Venus'); // Trying to add a duplicateconsole.log(planetsOrderFromSun.size); // Still 3, Did not add the duplicateplanetsOrderFromSun.clear();console.log(planetsOrderFromSun.size); // 0 弱集合，内存和垃圾回收JavaScript垃圾回收机制是一种内存管理形式，可以自动删除不再引用的对象并回收其资源。 JS中，当一个对象被引用的时候，往往意味着它正在被使用，或者在将来有可能会被使用。此时对象所占用的内存不会被垃圾回收机制回收掉。Map和Set所引用的对象会被保留，不允许进行垃圾回收。如果Map和Set引用着不再需要的大对象（例如已经从DOM中删除的DOM元素），这可能会消耗大量内存。 &nbsp; 为了解决这个问题，ES6还引入了两个名为WeakMap和WeakSet的新弱集合。这些ES6集合是“弱”的，因为它们允许从内存中清除不再需要的对象。 &nbsp;弱引用则可以理解为“引用了对象，但是不影响它的垃圾回收”，举个🌰: 1234567var obj = &#123;&#125;;var wm = new WeakMap();wm.set(obj, 1);wm.get(obj); // 1......obj = null;wm.get(obj); // 这句没有意义 在这个例子中，WeakMap实例wm（弱）引用了obj对象（空对象），接着下方代码释放了对空对象的引用（obj = null），此时和上例一样，空对象将被垃圾回收。也即wm中持有的空对象（弱）引用并不影响对对象本身的垃圾回收。这就是WeakMap中“弱引用”的含义。 WeakMapMDN对Map定义: WeakMap是一种弱引用key的键值对（key/value）集合，其键（key）必须是一个对象，值（value）可以为任意类型。正由于这样的弱引用，WeakMap的key是无法枚举的 (即无法列举所有的key)。如果key是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。所以无法使用for…in或者for…of等语句迭代。 WeakMap使用场景&nbsp;WeakMaps有几个流行的用例。它们可用于保持对象的私有数据私有化，它们还可用于跟踪DOM节点/对象。 场景一使用WeakMap简化了保持对象数据私有的过程。privateData可以引用Person对象，但不允许在没有特定Person实例的情况下访问，而且随Person实例对象的销毁而消失。 123456789101112var Person = (function() &#123; var privateData = new WeakMap(); function Person(name) &#123; privateData.set(this, &#123; name: name &#125;); &#125; Person.prototype.getName = function() &#123; return privateData.get(this).name; // 只能通过Person实例访问对应的name &#125;; return Person();&#125;()); 场景二使用WeakMap处理事件绑定,在React中如果用到事件监听处理，通常我们必须要在对应的生命周期中相应的进行事件绑定或解除，以防止内存泄漏。然而如果使用WeakMap，我可以不用担心这些问题。 123456789101112131415161718192021222324var listeners = new WeakMap();// 监听事件function on(object, event, fn)&#123; var thisListeners = listeners.get(object); if(!thisListeners) thisListeners = &#123;&#125;; if(!thisListeners[event]) thisListeners[event] = []; thisListeners[event].push(fn); listeners.set(object, thisListeners);&#125;// 触发事件function emit(object, event)&#123; var thisListeners = listeners.get(object); if(!thisListeners) thisListeners = &#123;&#125;; if(!thisListeners[event]) thisListeners[event] = []; thisListeners[event].forEach(function(fn)&#123; fn.call(object, event); &#125;);&#125;// 使用var obj = &#123;&#125;;on(obj, 'hello', function()&#123; console.log('hello');&#125;);emit(obj, 'hello'); 场景三使用WeakMap跟踪DOM节点编辑，删除和更改。例如，Google的Polymer项目在一段名为PositionWalker的代码中使用了WeakMap PositionWalker keeps track of a position within a DOM subtree, as a current node and an offset within that node. 12345678910111213141516171819202122_makeClone() &#123; this._containerClone = this.container.cloneNode(true); this._cloneToNodes = new WeakMap(); this._nodesToClones = new WeakMap(); ... let n = this.container; let c = this._containerClone; // find the currentNode's clone while (n !== null) &#123; if (n === this.currentNode) &#123; this._currentNodeClone = c; &#125; this._cloneToNodes.set(c, n); this._nodesToClones.set(n, c); n = iterator.nextNode(); c = cloneIterator.nextNode(); &#125;&#125; WeakSetMDN对Map定义: WeakSet是弱引用的Set，当不再需要它们引用的对象时，它们的元素可以被垃圾收集。 WeakSet不允许迭代。 123456789101112var ws = new WeakSet();var foo = &#123;&#125;;var bar = &#123;&#125;;ws.add(foo);ws.add(bar);ws.has(foo); // truews.has(bar); // truews.delete(foo); // removes foo from the setws.has(foo); // false, foo has been removed WeakSet使用场景WeakSet使用场景相当有限（至少目前为止）。大多数早期采用者都说WeakSet可用于标记对象而不会改变它们。ES6-Features.org有一个添加和删除WeakSet中元素的示例，以便跟踪对象是否已被标记: 12345678910111213141516171819202122232425262728293031323334353637let isMarked = new WeakSet()let attachedData = new WeakMap()export class Node&#123; constructor(id)&#123; this.id = id; &#125; mark()&#123; isMarked.add(this); &#125; unmark()&#123; isMarked.delete(this); &#125; marked()&#123; return isMarked.has(this); &#125; set data(data)&#123; attachedData.set(this, data); &#125; get data()&#123; return attachedData.get(this); &#125;&#125;let foo = new Node("foo")JSON.stringify(foo) === '&#123;"id":"foo"&#125;'foo.mark()foo.data = "bar"foo.data === "bar"JSON.stringify(foo) === '&#123;"id":"foo"&#125;'isMarked.has(foo) === trueattachedData.has(foo) === truefoo = null /* remove only reference to foo */attachedData.has(foo) === falseisMarked.has(foo) === false]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>Map</tag>
        <tag>Set</tag>
        <tag>WeakMap</tag>
        <tag>WeakSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈Web--JWT]]></title>
    <url>%2Fweb%2FLP20190709A%2F</url>
    <content type="text"><![CDATA[“The most amazing achievement of the computer software industry is its continuing cancellation of the steady and staggering gains made by the computer hardware industry.” —Henry Petroski 前言随着技术的发展，分布式web应用的普及，通过session管理用户登录状态成本越来越高，因此慢慢发展成为token的方式做登录身份校验，然后通过token去取redis中的缓存的用户信息，随着之后jwt的出现，校验方式更加简单便捷化，无需通过redis缓存，而是所有数据都保存在客户端，每次请求都发回服务器，随后服务器直接根据token取出保存的用户信息，以及对token可用性校验，单点登录更为简单。 这篇文章中主要讲解了关于JSON Web Tokens（JWT）的基础概念，以及解释JWT为什么会被广泛应用。JWT是确保应用程序信任和安全的重要部分，它允许以诸如用户数据之类的安全的方式声明表示。 为了JWT的工作原理，我们先来看一看关于它的抽象定义： JSON Web Token（JWT）是一种JSON对象，在RFC 7519中定义为表示双方之间的一组信息的安全方式；它由头部、有效负载和签名三部分组成。 我们完全可以把JWT简单地看成仅仅是符合以下格式的字符串 header.payload.signature Notes: 合法的JSON必须是使用双引号的字符串 为了理解JWT是如何被使用的，我们将使用User（用户）、Application Server（应用服务器）、Authentication Server（授权服务器）3个简单的实体加以解释说明。其中Authentication Server将提供JWT给用户，用户拿到JWT后就可以和应用（app/website）安全地通信。 上图中，User携带用户名/密码等可证明身份的内容去授权服务器获取JWT信息，每次服务都携带该Token内容与应用服务器进行交互，由应用服务器来验证Token是否是授权系统发放的有效Token，来验证当前业务是否请求是否合法。 接下来我们深入理解JWT是如何构造以及如何验证的。 第一步 创建头部（header）JWT的头部包含了JWT自身的签名算法信息，它是一个具有如下格式的JSON对象： 1234&#123; "typ": "JWT", "alg": "HS256"&#125; 这个JSON中, typ属性表示令牌的类型，JWT令牌统一写为JWT。alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256） 第二部 创建有效载荷（payload）JWT的有效载荷即是JWT的主体内容部分,包含了需要传递的数据（这些数据也被称为JWT的声明）。在我们的🌰中，JWT中存储了用户ID信息。 123&#123; "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"&#125; 上面的🌰中，我们的JWT仅仅存储了一个信息。然而JWT 规定了7个官方字段，供选用 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 当然除了官方字段，你还可以在这个部分定义私有字段，诸如： 12345&#123; "sub": "1234567890", "name": "John Doe", "admin": true&#125; 值得注意的是有效载荷的存储数据的大小会影响整个JWT的大小，一般来说对JWT的大小没有限制但是过大的JWT可能会影响性能或造成潜在的问题。 第三步 创建签名（signature）签名是为了防止数据被篡改。 JWT的签名使用以下伪代码实现： 1234// signature algorithmdata = base64urlEncode( header ) + “.” + base64urlEncode( payload )hashedData = hash( data, secret )signature = base64urlEncode( hashedData ) 该算法所做的使用base64urlEncode对在第一步创建的头部和第二部中的有效负载分别进行编码并用”.”号拼接成字符串。随后使用JWT头中指定的散列算法对字符串使用密钥进行散列。最后再使用base64urlEncode对生成的散列数据进行编码以产生JWT签名。（密钥只有服务器才知道，不能泄露给用户） 这篇文章中，使用base64urlEncode对header和payload进行编码后得到如下结果： 1234567891011// headerbase64urlEncode(&#123; "typ": "JWT", "alg": "HS256"&#125;)eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9// payload// base64urlEncode(&#123; "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"&#125;)eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ 然后将结果代入上面的伪代码会得到如下签名： 12// signature-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM 第四步 生成JWT现在我们已经创建完成了JWT的header、payload、signature3个部分，那么再按照 header.payload.signature 的格式将3个部分组合起来就是所谓的JWT了。如下就是我们🌰中的JWT 12// JWTeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM 在JWT官方网站，你可以尝试创建自己的JWT。 回到我们的案例，这个Authentication Server 已经创建了一个JWT，并且发给了用户。 JWT是怎么保护数据的注意，这里经常会有一个误区，JWT本身和安全没关系，它就仅仅只是一个字符串，使用它来做安全远不如类似于RSA2这样的非对称加密的形式来的实在，由于客户端的程序对用户几乎完全透明，验签的过程对于他们来讲也是透明的，所以安全性肯定不会靠这个来实现，如果实在怕JWT的被盗取，可以考虑在Payload部分加入一些客户端独有的非敏感信息，用于在服务端来进行核验，比如使用MAC-Message Authentication Code、或者公钥之类的等等; 或者干脆就把生效时间设置的短一些，也可以减少暴露的风险。 JWT的数据被编码和被签名，但是没有被加密。编码的目的是转化数据结构，签名是为了数据的接收者验证数据的权威性。所以编码和签名并不会保护数据的安全性。而加密的主要目的才是为了保护数据安全防止未授权访问。对于详细描述编码与加密的区别，可以参考这篇文章。 Since JWT are signed and encoded only, and since JWT are not encrypted, JWT do not guarantee any security for sensitive data. 由于JWT仅仅被编码和签名而没有被加密过的，所以它无法保证任何敏感信息的安全性。 第五步 验证JWT第四步中我们已经知道JWT的签名生成需要用密钥（secret），这个密钥只有授权服务器知道。应与服务器开启认证处理时，需要从授权服务器获取此密钥。此后当用户携带JWT访问应用服务器时，应用服务器拿到JWT后可以通过类似第三步的方法生成一个签名，然后与用户携带的JWT的签名进行对比从而验证用户JWT是否有效。 结束语本文中描述的JWT认证设置使用对称密钥算法（HS256）。您也可以使用非对称算法（例如RS256），即授权服务器具有密钥，并且应用程序服务器具有公钥。了解使用对称和非对称算法之间差异的详细分类。 还应该注意，JWT应该通过HTTPS连接（而不是HTTP）发送。HTTPS有助于防止未经授权的用户窃取所发送的JWT，从而无法拦截服务器和用户之间的通信。 同时，JWT应该设置有效期，并且有效期不要太长。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶--bind函数]]></title>
    <url>%2Fweb%2FLP20190705A%2F</url>
    <content type="text"><![CDATA[“Programmers are in a race with the Universe to create bigger and better idiot-proof programs, while the Universe is trying to create bigger and better idiots. So far the Universe is winning.” —Rich Cook 官方描述首先我们先来看看MDN上对于bind函数的定义，主要有三个特点: bind函数会创建一个新函数（称为绑定函数），新函数与原函数具有相同的函数体（在 ECMAScript 5 规范中内置的call属性） 当生成的新函数被调用执行时，其this值始终指向bind函数的第一个参数且无法改变 bin函数可以接受预设的参数，该参数最终提供给原函数 新函数也能使用new操作符创建对象,这种行为就像把原函数当成构造器。提供的 this值被忽略，同时调用时的参数被提供给模拟函数 用例说明众所周知，JS中函数(ES6箭头函数除外)的this指向是在函数执行时动态绑定的，函数定义和实际运行时的所处的环境不一样，往往导致未知的bug。 尤其是在React组件中，经常会由于this指向问题导致无法调用到函数，所以通常我们会在constructor函数中使用bind函数来绑定this(当然一般我们都会使用箭头函数来避免此类情况)。 123456789101112131415var name = "paopaolee"function test()&#123; console.log(this.name)&#125;var obj = &#123; name: "lepaopao", print: test,&#125;test(); // paopaoleeobj.print(); // lepaopaovar obj1 = &#123; name: 'xxxxxx', print: test.bind(this) // 返回了一个新函数并且this指向window&#125;obj1.print(); // paopaolee 动手实现第一版目标：实现描述中的特征1、2、3 分析：返回的结果是一个函数；新函数调用时this指向第一个参数， 可以通过call/apply函数解决，call/apply函数的区别在于参数传递，前者需逐一列出，后者可以传递数组；bind函数可接受预设参数最终提供原函数，由于参数不确定，所以选用apply实现。 实现： 12345678Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var self = this; //普通调用时， this指向bind调用者 var args = slice(arguments, 1); return function () &#123; self.apply(Othat, args); &#125;&#125; 第二版问题：第一版中初步实现了前三个特征，当然还有诸多问题，例如如果新函数执行时需要有返回值、第一版中实现了绑定时传参，那新函数调用时传参数呢？以及bind函数调用不正确等等。 优化： 1234567891011121314Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); return function () &#123; // 解决: 新函数执行时return返回值 return self.apply(Othat, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125;&#125; 第三版目标： 解决bind函数的第三个特征: 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说bind执行返回的新函数作为构造函数执行时，bind时指定的对象(参数Othat)会失效，但是传入的参数依然有效。 举个🌰： 123456789101112131415161718var vaule = 2var obj = &#123; value: 1&#125;function female(name, age)&#123; this.favorite = 'shopping'; console.log(this.value); console.log(name, age);&#125;female.prototype.husband = 'leepaopao';var boundFunc = female.bind(obj, 'paopaolee');var p = new bindedFunc(23);// undefined// paopaolee 23consple.log(p.habit); // shoppingconsple.log(p.husband); // leepaopao 尽管在window以及obj中都声明了value值，但最终(this.value)依然返回了undefined，说明此时this即不指向window也不指向obj，bind时绑定的this（obj）失效了。所以此时this真正指向的是female的实例。 分析： 要判断新函数调用时是否为new构造函数调用，可以通过this是否为新函数的实例,所以我们把返回的匿名函数换成具名函数，以便判断。 实现 1234567891011121314151617Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; return boundFunc;&#125; 第四版问题： 第三版中，我们解决了bind函数的第4个特征，但是使用new操作符创建对象时，this指向的是boundFunc的实例，无法继承原函数的原型中的属性，原型链遭到破坏。 目标：重塑原型链 实现： 123456789101112131415161718Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; boundFunc.prototype = this.portotype; return boundFunc;&#125; 上述代码，重塑原型链的做法是直接将boundFunc.prototype = this.prototype，相当于直接用原函数的prototype覆盖掉了boundFunc函数原来的prototype，这样如果我们更改boundFunc.prototype中的属性是也会影响原函数的prototype上的属性。 最终版12345678910111213141516171819202122232425Function.prototype.paopaoleeBind = function (Othat) &#123; var slice = Array.prototype.slice; var toString = Array.portotype.toString; var self = this; // 解决: 非法调用 if(typeof self !=== 'function' || toString(self) !== [object Function])&#123; throw new TypeError("incorrectly call"); &#125; var args = slice(arguments, 1); function boundFunc() &#123; // 判断this是否为boundFunc实例，如果是说明是new构造函数调用，否则是普通调用 var Othis = this instanceof boundFunc ? this : Othat; // 解决: 新函数执行时return返回值 return self.apply(Othis, args.concat(slice.call(arguments))); // 解决: 新函数执行可接受参数 &#125; // 重塑原型链: 方法一 boundFunc.prototype = Object.create(this.portotype); // 重塑原型链: 方法二 /**** function fNOP ()&#123;&#125; fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); ****/ return boundFunc;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
